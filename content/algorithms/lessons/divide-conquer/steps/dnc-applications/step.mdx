---
id: dnc-applications
title: Divide and Conquer Applications
order: 2
---

# Divide and Conquer Applications

Real-world applications of the divide and conquer paradigm.

## Closest Pair of Points

```c
typedef struct {
    double x, y;
} Point;

int compareX(const void *a, const void *b) {
    Point *p1 = (Point *)a;
    Point *p2 = (Point *)b;
    return p1->x > p2->x ? 1 : -1;
}

double dist(Point p1, Point p2) {
    return sqrt((p1.x - p2.x) * (p1.x - p2.x) +
                (p1.y - p2.y) * (p1.y - p2.y));
}

double stripClosest(Point strip[], int size, double d) {
    double min = d;
    qsort(strip, size, sizeof(Point), compareY);

    for (int i = 0; i < size; i++) {
        for (int j = i + 1; j < size &&
             (strip[j].y - strip[i].y) < min; j++) {
            double d = dist(strip[i], strip[j]);
            if (d < min) min = d;
        }
    }
    return min;
}

double closestPair(Point points[], int n) {
    if (n <= 3) {
        double min = DBL_MAX;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                double d = dist(points[i], points[j]);
                if (d < min) min = d;
            }
        }
        return min;
    }

    int mid = n / 2;
    Point midPoint = points[mid];

    double dl = closestPair(points, mid);
    double dr = closestPair(points + mid, n - mid);
    double d = min(dl, dr);

    Point strip[n];
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (fabs(points[i].x - midPoint.x) < d) {
            strip[j++] = points[i];
        }
    }

    return min(d, stripClosest(strip, j, d));
}
```

## Convex Hull (QuickHull)

```c
typedef struct {
    int x, y;
} Point2D;

int orientation(Point2D p, Point2D q, Point2D r) {
    int val = (q.y - p.y) * (r.x - q.x) -
              (q.x - p.x) * (r.y - q.y);
    if (val == 0) return 0;
    return (val > 0) ? 1 : 2;
}

double dist(Point2D p, Point2D q, Point2D r) {
    // Distance from line pq to point r
    return fabs((r.y - p.y) * (q.x - p.x) -
                (q.y - p.y) * (r.x - p.x));
}

void quickHull(Point2D points[], int n, Point2D p, Point2D q,
               Point2D hull[], int *hullSize, int side) {
    int idx = -1;
    double maxDist = 0;

    for (int i = 0; i < n; i++) {
        int o = orientation(p, q, points[i]);
        if (o == side) {
            double d = dist(p, q, points[i]);
            if (d > maxDist) {
                maxDist = d;
                idx = i;
            }
        }
    }

    if (idx == -1) {
        hull[(*hullSize)++] = q;
        return;
    }

    quickHull(points, n, points[idx], p, hull, hullSize,
              orientation(points[idx], p, q));
    quickHull(points, n, points[idx], q, hull, hullSize,
              orientation(p, q, points[idx]));
}
```

## Integer Multiplication (Karatsuba)

```c
// Multiply two n-digit numbers in O(n^log2(3)) â‰ˆ O(n^1.585)
void karatsuba(int a, int b, int *result) {
    if (a < 10 || b < 10) {
        *result = a * b;
        return;
    }

    int n = max(numDigits(a), numDigits(b));
    int half = n / 2;

    int aHigh = a / pow10(half);
    int aLow = a % pow10(half);
    int bHigh = b / pow10(half);
    int bLow = b % pow10(half);

    int z2, z3, z0, z1;
    karatsuba(aHigh, bHigh, &z2);
    karatsuba(aLow, bLow, &z0);
    karatsuba(aHigh + aLow, bHigh + bLow, &z1);
    karatsuba(z1 - z2 - z0, 1, &z3);

    *result = z2 * pow10(2 * half) + (z2 + z3) * pow10(half) + z0;
}
```

## Comparison: Divide and Conquer vs Dynamic Programming

| Aspect         | D&C                   | DP                |
| -------------- | --------------------- | ----------------- |
| Subproblems    | Independent           | Overlapping       |
| Memoization    | Not needed            | Essential         |
| Recursion tree | No repeated nodes     | Repeated nodes    |
| Example        | Merge sort            | Fibonacci         |
| Optimization   | Often O(log n) levels | Often O(n) states |
