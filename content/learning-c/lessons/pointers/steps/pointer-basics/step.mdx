---
title: "Pointer Basics"
order: 1
---

# Pointer Basics

A **pointer** is a variable that stores the memory address of another variable. Instead of holding a value directly, a pointer "points to" where the value lives in memory.

## Core Concepts

Every variable in your program occupies a location in memory. Each memory location has an **address** (like a house number). Pointers let you work with these addresses directly.

### The Two Essential Operators

1. **`&` (address-of)**: Gets the memory address of a variable
2. **`*` (dereference)**: Accesses the value at a memory address

## Understanding Pointers: A Mental Model

**Think of it like this:** Imagine your computer's memory as a long street with houses (memory locations). Each house has:
- **An address** (e.g., 123 Main Street) - This is the memory address
- **Contents inside** (furniture, people) - This is the actual data

**A regular variable** is like knowing "My couch is in house 123." You only care about the couch (the value).

**A pointer** is like having a GPS coordinate or a written address: "The couch is at 123 Main Street." You have the address itself, and you can:
- **Follow the address** to find the house (dereferencing: `*ptr`)
- **Share the address** with others (passing pointers to functions)
- **Change where you're pointing** (point to a different house)

**Visual representation:**
```
Memory:
Address:  0x1000    0x1004    0x1008    0x100C
Value:    [  42  ]  [????]    [ ptr ]   [????]

Variable x is at 0x1000, contains 42
Variable ptr is at 0x1008, contains 0x1000 (the address of x)

ptr → points to → x
0x1008 stores 0x1000 (address)
*ptr gives you 42 (value at address 0x1000)
```

**Key insight:**
- `x` gives you the value directly (42)
- `&x` gives you where x lives (0x1000)
- `ptr` stores an address (0x1000)
- `*ptr` follows that address to get the value (42)

**This explains why:**
- You need `&` to get an address: `ptr = &x;`
- You need `*` to read through an address: `value = *ptr;`
- Pointers and regular variables are different types (you can't just assign them)
- Uninitialized pointers are dangerous (like a random GPS coordinate - could be anywhere!)

## Declaring Pointers

```c
#include <stdio.h>

int main(void) {
    int x = 42;           // Regular integer variable
    int *ptr;             // Pointer to an integer (uninitialized - dangerous!)

    ptr = &x;             // ptr now holds the address of x

    printf("Value of x: %d\n", x);              // 42
    printf("Address of x: %p\n", (void*)&x);    // Memory address (e.g., 0x7fff5fbff8bc)
    printf("Value of ptr: %p\n", (void*)ptr);   // Same address
    printf("Value at ptr: %d\n", *ptr);         // 42 (dereference to get value)

    return 0;
}
```

**Key points:**
- `int *ptr` declares a pointer to an integer
- The `*` in the declaration means "pointer to"
- The `*` when using the pointer means "value at"
- `%p` is the format specifier for printing addresses

## Using Pointers to Modify Values

```c
#include <stdio.h>

int main(void) {
    int value = 10;
    int *ptr = &value;     // Initialize pointer with address of value

    printf("Before: value = %d\n", value);     // 10

    *ptr = 20;             // Modify value through pointer

    printf("After: value = %d\n", value);      // 20 (changed!)

    // Both refer to the same memory location
    printf("value is at: %p\n", (void*)&value);
    printf("ptr points to: %p\n", (void*)ptr);

    return 0;
}
```

When you dereference a pointer on the left side of an assignment (`*ptr = 20`), you're changing the value at that memory address.

## Pointer Declaration Styles

```c
#include <stdio.h>

int main(void) {
    int x = 1, y = 2, z = 3;

    // Style 1: * next to type (can be misleading)
    int* p1, p2;       // p1 is a pointer, p2 is NOT! (Common mistake)

    // Style 2: * next to variable name (clearer)
    int *p3, *p4;      // Both are pointers

    // Style 3: One declaration per line (safest)
    int *p5;
    int *p6;

    p1 = &x;
    p2 = y;            // p2 is just an int, not a pointer
    p3 = &y;
    p4 = &z;
    p5 = &x;
    p6 = &z;

    printf("p1 points to: %d\n", *p1);   // 1
    printf("p2 is: %d\n", p2);           // 2 (not a pointer!)
    printf("p3 points to: %d\n", *p3);   // 2

    return 0;
}
```

**Best practice:** Declare one pointer per line to avoid confusion, and place the `*` next to the variable name.

## Multiple Pointers to Same Location

```c
#include <stdio.h>

int main(void) {
    int target = 100;
    int *ptr1 = &target;
    int *ptr2 = &target;
    int *ptr3 = ptr1;      // Copy pointer value (not the target value)

    printf("Initial: target = %d\n", target);    // 100

    *ptr1 = 200;
    printf("After *ptr1 = 200: target = %d\n", target);    // 200

    *ptr2 = 300;
    printf("After *ptr2 = 300: target = %d\n", target);    // 300

    *ptr3 = 400;
    printf("After *ptr3 = 400: target = %d\n", target);    // 400

    // All pointers point to the same memory
    printf("All three pointers: %p, %p, %p\n",
           (void*)ptr1, (void*)ptr2, (void*)ptr3);

    return 0;
}
```

Multiple pointers can point to the same variable. Changes through any pointer affect the same memory location.

## Why This Matters

Pointers are fundamental to C programming and understanding them unlocks powerful capabilities:

**1. Efficient Function Parameters**
Without pointers, functions can only work with copies of your data. Pointers let functions modify the original:
```c
void increment(int *num) {
    (*num)++;  // Modifies the original variable
}

int value = 5;
increment(&value);  // value is now 6
```

**2. Dynamic Data Structures**
Linked lists, trees, graphs - all require pointers to connect nodes:
```c
struct Node {
    int data;
    struct Node *next;  // Points to the next node
};
```

**3. Dynamic Memory Allocation**
`malloc()` returns a pointer to heap memory, letting you create data of any size at runtime:
```c
int *array = malloc(n * sizeof(int));  // Size determined at runtime
```

**4. String Manipulation**
C strings are character pointers - understanding pointers is essential for text processing:
```c
char *str = "Hello";  // Pointer to first character
```

**5. Arrays and Pointer Arithmetic**
Array indexing is really pointer arithmetic under the hood:
```c
arr[i]  <==>  *(arr + i)  // These are equivalent!
```

**What breaks if you get pointers wrong:**
- **Segmentation faults** - Dereferencing invalid pointers crashes your program
- **Memory leaks** - Losing pointer references means you can't free memory
- **Data corruption** - Writing to wrong addresses overwrites random data
- **Security vulnerabilities** - Pointer errors are exploited in many attacks

**In real code:**
- Operating systems use pointers for memory management
- Databases use pointers for indexes and data structures
- Game engines use pointers for object references
- Network code uses pointers for packet buffers
- **Nearly every C program** uses pointers extensively

Mastering pointers is what separates beginners from proficient C programmers.

## Debugging: Error Messages You'll See

### Error: `segmentation fault (core dumped)`

**What it means:** You tried to access memory you don't own (dereferencing an invalid pointer).

**Common causes:**
```c
int *ptr;           // Uninitialized
*ptr = 42;          // CRASH! Random address

int *ptr = NULL;
*ptr = 42;          // CRASH! Can't write to address 0

int x = 10;
int *ptr = &x;
free(ptr);          // WRONG! Can't free stack memory
```

**How to debug:**
- Use `gdb`: `gdb ./program`, then `run`
- When it crashes: `backtrace` shows where
- Use `-fsanitize=address` to catch earlier: `gcc -fsanitize=address -g program.c`

### Error: `warning: initialization of 'int *' from 'int' makes pointer from integer without a cast`

**What it means:** You're trying to assign a value to a pointer (should be an address).

**Example:**
```c
int x = 42;
int *ptr = x;  // WRONG! ptr needs an address, not a value
```

**The fix:**
```c
int *ptr = &x;  // CORRECT! Use & to get the address
```

### Error: `warning: format '%d' expects argument of type 'int', but argument has type 'int *'`

**What it means:** You're printing a pointer with `%d` (for integers) instead of `%p` (for pointers).

**Example:**
```c
int *ptr = &x;
printf("%d\n", ptr);  // WRONG! ptr is an address, not an int
```

**The fix:**
```c
printf("%p\n", (void*)ptr);  // Print the address
printf("%d\n", *ptr);        // Print the value it points to
```

### Error: `warning: dereferencing type-punned pointer will break strict-aliasing rules`

**What it means:** You're casting pointers between incompatible types unsafely.

**Example:**
```c
int x = 42;
float *ptr = (float*)&x;  // Dangerous type punning
```

**How to fix:** Avoid casting pointers to incompatible types unless you know what you're doing (usually in low-level code).

### Runtime Error: Garbage Value

**What happens:** Your pointer is uninitialized, so dereferencing it reads random memory.

**Example:**
```c
int *ptr;              // Uninitialized - contains garbage address
printf("%d\n", *ptr);  // Prints random number or crashes
```

**What you might see:**
```
2847562  (random number)
OR
Segmentation fault
```

**The fix:** Always initialize pointers before use:
```c
int *ptr = NULL;  // Safe: explicitly uninitialized
// OR
int x = 10;
int *ptr = &x;    // Safe: points to valid memory
```

## Common Pitfalls

### Pitfall 1: Uninitialized Pointers (Wild Pointers)

**Why it happens:** Local pointers contain whatever random bits were in memory at that location.

```c
int *ptr;              // Uninitialized - contains garbage address (e.g., 0x7ffc8b0d2a84)
*ptr = 42;             // CRASH! Writing to random memory location
```

**What you'll see:**
```
Segmentation fault (core dumped)
```

Or with AddressSanitizer (`gcc -fsanitize=address`):
```
SEGV on unknown address 0x7ffc8b0d2a84
```

**The fix:**
```c
int *ptr = NULL;       // Explicitly set to NULL
// OR
int x = 0;
int *ptr = &x;         // Point to valid memory immediately
```

**Best practice:** Always initialize pointers when you declare them. An uninitialized pointer is like having a random GPS coordinate - following it leads to disaster.

**Prevention:**
- Compile with `-Wall -Wextra` to get warnings about uninitialized variables
- Use AddressSanitizer during development: `-fsanitize=address`
- Set pointers to `NULL` if you don't have a valid address yet
- Check `if (ptr != NULL)` before dereferencing when unsure

### Pitfall 2: Confusing & and *

```c
int x = 5;
int *ptr = &x;

printf("%d", *x);      // ERROR: x is not a pointer
printf("%d", &ptr);    // ERROR: prints address of pointer variable, not what it points to
printf("%d", *ptr);    // CORRECT: prints 5
```

### Pitfall 3: Declaration vs. Dereference Context

```c
int *ptr;              // * means "pointer to" (declaration)
*ptr = 10;             // * means "value at" (dereference)
```

The `*` symbol has different meanings in different contexts. Learn to recognize which is which.

### Pitfall 4: Type Mismatch

```c
int x = 42;
float *ptr = &x;       // ERROR: type mismatch
                       // Pointer type must match variable type
```

A pointer's type must match what it points to. You can't assign an `int*` to a `float*` without explicit casting (and that's usually wrong).

## Safety Checklist

Before dereferencing any pointer, ask yourself:

1. **Is it initialized?** Never dereference an uninitialized pointer
2. **Is it NULL?** Check before dereferencing (we'll cover NULL in the next step)
3. **Does it point to valid memory?** Don't point to freed or out-of-scope memory
4. **Is the type correct?** Pointer type should match the variable type

## Key Takeaways

- A pointer stores a memory address
- `&variable` gets the address of a variable
- `*pointer` accesses the value at an address
- Always initialize pointers before use
- Pointer type must match the pointed-to type
- Multiple pointers can point to the same location
- The `*` symbol means different things in declaration vs. usage

## Exercises

1. **Address Explorer**: Write a program that declares three different types of variables (int, float, char) and prints both their values and addresses. Observe the address patterns.

2. **Pointer Chain**: Create a variable, then create two pointers that both point to it. Modify the variable through the first pointer and verify the change is visible through the second pointer.

3. **Swap Attempt**: Try to write a function that swaps two integers. First attempt: pass the integers directly (it won't work). Why not? We'll solve this properly in a later step.

4. **Pointer Arithmetic Preview**: Create an integer and a pointer to it. Print the pointer's value, then print `ptr + 1` (don't dereference it). What do you notice about the difference? (We'll explore this in detail soon.)

5. **Type Safety**: Experiment with assigning pointers of different types. What compiler warnings or errors do you get? Try with `-Wall` flag to see all warnings.
