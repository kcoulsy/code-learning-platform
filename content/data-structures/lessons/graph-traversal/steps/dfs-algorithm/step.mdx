---
id: dfs-algorithm
title: Depth-First Search
order: 2
---

# Depth-First Search (DFS)

DFS explores as deep as possible before backtracking. It uses recursion or a stack and is useful for cycle detection and topological sorting.

## Recursive DFS

```c
void dfsHelper(AdjListGraph *g, int vertex, int visited[]) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    GNode *current = g->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->vertex]) {
            dfsHelper(g, current->vertex, visited);
        }
        current = current->next;
    }
}

void dfs(AdjListGraph *g, int start) {
    int visited[MAX_VERTICES] = {0};
    printf("DFS: ");
    dfsHelper(g, start, visited);
    printf("\n");
}
```

## Iterative DFS

```c
void dfsIterative(AdjListGraph *g, int start) {
    int visited[MAX_VERTICES] = {0};
    Stack s;
    initStack(&s);

    push(&s, start);

    printf("DFS (Iterative): ");
    while (!isEmpty(&s)) {
        int current = pop(&s);
        if (!visited[current]) {
            visited[current] = 1;
            printf("%d ", current);

            GNode *node = g->adjList[current];
            while (node != NULL) {
                if (!visited[node->vertex]) {
                    push(&s, node->vertex);
                }
                node = node->next;
            }
        }
    }
    printf("\n");
}
```

## Cycle Detection

```c
int hasCycle(AdjListGraph *g) {
    int visited[MAX_VERTICES] = {0};
    int recStack[MAX_VERTICES] = {0};

    for (int i = 0; i < g->vertices; i++) {
        if (!visited[i]) {
            if (cycleDetectHelper(g, i, visited, recStack)) {
                return 1;
            }
        }
    }
    return 0;
}

int cycleDetectHelper(AdjListGraph *g, int vertex, int visited[], int recStack[]) {
    visited[vertex] = 1;
    recStack[vertex] = 1;

    GNode *current = g->adjList[vertex];
    while (current != NULL) {
        int neighbor = current->vertex;
        if (!visited[neighbor]) {
            if (cycleDetectHelper(g, neighbor, visited, recStack)) {
                return 1;
            }
        } else if (recStack[neighbor]) {
            return 1;  // Back edge found
        }
        current = current->next;
    }

    recStack[vertex] = 0;
    return 0;
}
```

## Topological Sort (using DFS)

```c
void topologicalSortHelper(AdjListGraph *g, int vertex, int visited[], Stack *s) {
    visited[vertex] = 1;

    GNode *current = g->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->vertex]) {
            topologicalSortHelper(g, current->vertex, visited, s);
        }
        current = current->next;
    }
    push(s, vertex);
}

void topologicalSort(AdjListGraph *g) {
    int visited[MAX_VERTICES] = {0};
    Stack s;
    initStack(&s);

    for (int i = 0; i < g->vertices; i++) {
        if (!visited[i]) {
            topologicalSortHelper(g, i, visited, &s);
        }
    }

    printf("Topological Sort: ");
    while (!isEmpty(&s)) {
        printf("%d ", pop(&s));
    }
    printf("\n");
}
```

## BFS vs DFS

| Feature        | BFS                   | DFS                      |
| -------------- | --------------------- | ------------------------ |
| Order          | Level by level        | Deep as possible         |
| Data Structure | Queue                 | Stack (or recursion)     |
| Shortest Path  | Yes (unweighted)      | No                       |
| Memory         | O(V) (worst case)     | O(V) (recursion depth)   |
| Use Cases      | Shortest path, levels | Cycles, paths, backtrack |
