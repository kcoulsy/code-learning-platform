---
id: for-loops
title: For Loops
order: 4
---

# For Loops

For loops are ideal when you know in advance how many times you want to repeat something. They combine initialization, condition checking, and updating in one compact statement.

## Basic For Loop Structure

**Syntax:** `for (initialization; condition; update) { body }`

```c
#include <stdio.h>

int main(void) {
    // initialization; condition; update
    for (int i = 1; i <= 5; i++) {
        printf("Count: %d\n", i);
    }

    return 0;
}
```

**How it works:**
1. **Initialization** (`int i = 1`): Runs once before the loop starts
2. **Condition** (`i <= 5`): Checked before each iteration
3. **Body** (`printf...`): Executes if condition is true
4. **Update** (`i++`): Runs after each iteration
5. Repeat steps 2-4 until condition is false

## Understanding For Loops: A Mental Model

**Think of it like this:** A for loop is like walking through a row of houses on a street.

**Visual representation:**
```
Houses:  [1]  [2]  [3]  [4]  [5]
          ↑
Start here (i = 1)
Check: Am I past house 5? (i <= 5)
No → Visit house (loop body)
Step forward (i++)
Check again...
```

**Key insight:** The loop counter `i` is like your position marker. You:
1. Start at a position (initialization)
2. Check if you should continue (condition)
3. Do something at current position (body)
4. Move to next position (update)
5. Repeat check

**This explains why:**
- `i < n` visits indices 0 to n-1 (n items)
- `i <= n` visits indices 0 to n (n+1 items) - usually a bug!
- Order matters: init → check → body → update → check → body → ...
- The condition is checked BEFORE the first iteration (loop might not run at all)

### The Fencepost Problem (Off-By-One Errors)

**Classic question:** If you want to build a fence with 10 sections, how many posts do you need?

```
Fence: |===|===|===|===|===|===|===|===|===|===|
Posts:  1   2   3   4   5   6   7   8   9  10  11

Answer: 11 posts! (one more than the number of sections)
```

**In arrays:**
```c
int arr[10];  // 10 elements

// WRONG: Tries to access 11 elements (0 through 10)
for (int i = 0; i <= 10; i++) {  // Off by one!
    arr[i] = i;  // arr[10] is OUT OF BOUNDS!
}

// CORRECT: Accesses exactly 10 elements (0 through 9)
for (int i = 0; i < 10; i++) {
    arr[i] = i;  // arr[0] to arr[9] - perfect!
}
```

**Mental model:**
- Array of size `n` has indices `0` to `n-1` (n total items)
- Use `i < n`, not `i <= n`
- Think: "Less than the SIZE, not less-than-or-equal"

**Visual:**
```
Array size: 5
Indices:    [0] [1] [2] [3] [4]
                                 [5] ← OUT OF BOUNDS!

for (i = 0; i < 5; i++)   ✓ Correct: visits 0,1,2,3,4
for (i = 0; i <= 5; i++)  ✗ Bug: tries to visit 0,1,2,3,4,5
```

**How to debug off-by-one errors:**
1. **Print loop counter**: Add `printf("i = %d\n", i);` to see what values it takes
2. **Check first and last**: Manually trace first iteration (i=0) and last (i=n-1)
3. **Count iterations**: If size is 10, loop should run exactly 10 times
4. **Use array size**: `i < sizeof(arr)/sizeof(arr[0])` instead of hardcoding

## Common For Loop Patterns

### Counting Up

```c
#include <stdio.h>

int main(void) {
    // Print 0 to 9
    for (int i = 0; i < 10; i++) {
        printf("%d ", i);
    }
    printf("\n");
    // Output: 0 1 2 3 4 5 6 7 8 9

    return 0;
}
```

### Counting Down

```c
#include <stdio.h>

int main(void) {
    // Print 10 to 1
    for (int i = 10; i >= 1; i--) {
        printf("%d ", i);
    }
    printf("\n");
    // Output: 10 9 8 7 6 5 4 3 2 1

    return 0;
}
```

### Custom Step Size

```c
#include <stdio.h>

int main(void) {
    // Print even numbers 0 to 20
    for (int i = 0; i <= 20; i += 2) {
        printf("%d ", i);
    }
    printf("\n");
    // Output: 0 2 4 6 8 10 12 14 16 18 20

    return 0;
}
```

## Practical Examples

### Sum of Numbers

```c
#include <stdio.h>

int main(void) {
    int n = 100;
    int sum = 0;

    for (int i = 1; i <= n; i++) {
        sum += i;
    }

    printf("Sum of 1 to %d = %d\n", n, sum);
    // Output: Sum of 1 to 100 = 5050

    return 0;
}
```

### Multiplication Table

```c
#include <stdio.h>

int main(void) {
    int number = 7;

    printf("Multiplication table for %d:\n", number);
    for (int i = 1; i <= 10; i++) {
        printf("%d x %d = %d\n", number, i, number * i);
    }

    return 0;
}
```

### Factorial Calculation

```c
#include <stdio.h>

int main(void) {
    int n = 5;
    long long factorial = 1;

    for (int i = 1; i <= n; i++) {
        factorial *= i;
    }

    printf("%d! = %lld\n", n, factorial);
    // Output: 5! = 120

    return 0;
}
```

### Pattern Printing

```c
#include <stdio.h>

int main(void) {
    int rows = 5;

    // Right-angled triangle
    for (int i = 1; i <= rows; i++) {
        for (int j = 1; j <= i; j++) {
            printf("* ");
        }
        printf("\n");
    }

    return 0;
}
```

Output:
```
*
* *
* * *
* * * *
* * * * *
```

## Nested For Loops

```c
#include <stdio.h>

int main(void) {
    // Multiplication table (1-10)
    printf("    ");
    for (int i = 1; i <= 10; i++) {
        printf("%4d", i);
    }
    printf("\n");
    printf("    ");
    for (int i = 0; i < 40; i++) printf("-");
    printf("\n");

    for (int i = 1; i <= 10; i++) {
        printf("%2d |", i);
        for (int j = 1; j <= 10; j++) {
            printf("%4d", i * j);
        }
        printf("\n");
    }

    return 0;
}
```

## For Loop Variations

### Multiple Initializations/Updates

```c
#include <stdio.h>

int main(void) {
    // Multiple variables
    for (int i = 0, j = 10; i < j; i++, j--) {
        printf("i=%d, j=%d\n", i, j);
    }

    return 0;
}
```

### Infinite For Loop

```c
#include <stdio.h>

int main(void) {
    int count = 0;

    // All parts optional (but semicolons required)
    for (;;) {
        printf("Count: %d\n", count);
        count++;

        if (count >= 5) {
            break;  // Exit the infinite loop
        }
    }

    return 0;
}
```

### For Loop as While Loop

```c
// These are equivalent:

// For loop style
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}

// While loop style
int i = 0;
while (i < 10) {
    printf("%d ", i);
    i++;
}
```

## Why This Matters

For loops are fundamental to programming and appear everywhere in real code:

**1. Array Processing**
Almost every array operation uses a for loop:
```c
// Searching
for (int i = 0; i < size; i++) {
    if (arr[i] == target) return i;
}

// Sorting algorithms (bubble sort, selection sort)
for (int i = 0; i < n-1; i++) {
    for (int j = i+1; j < n; j++) {
        if (arr[i] > arr[j]) swap(&arr[i], &arr[j]);
    }
}
```

**2. Algorithm Implementation**
Most algorithms rely on iteration:
- **Searching**: Linear search, binary search
- **Sorting**: Bubble sort, insertion sort, quicksort
- **Mathematical**: Computing factorials, prime numbers, Fibonacci
- **String processing**: Parsing, validation, transformation

**3. Data Structure Operations**
Traversing linked lists, trees, graphs:
```c
// Linked list traversal
for (Node *curr = head; curr != NULL; curr = curr->next) {
    process(curr->data);
}
```

**4. Performance-Critical Code**
Tight loops are often the bottleneck:
- Game engines (rendering each frame)
- Image processing (each pixel)
- Scientific computing (numerical simulations)
- Database queries (scanning records)

**What breaks if you get loops wrong:**
- **Off-by-one errors** - Process wrong number of items, miss last element, or access out of bounds
- **Infinite loops** - Wrong condition means loop never ends, program hangs
- **Performance** - Nested loops can become O(n²) or worse
- **Buffer overflows** - Loop past array bounds corrupts memory

**In real code:**
- Operating systems use loops to process events
- Web servers loop through incoming connections
- Compilers loop through source code tokens
- Games loop every frame (60+ times per second)

Mastering for loops is essential for writing any non-trivial program.

## Debugging: Common Loop Problems and How to Find Them

### Problem: Loop Runs One Too Many/Few Times

**Symptoms:**
- Missing last element
- Array index out of bounds
- Extra iteration with garbage data

**Debugging technique:**
```c
// Add debug prints
for (int i = 0; i < n; i++) {
    printf("Iteration %d: processing arr[%d] = %d\n", i, i, arr[i]);
    // ... your code
}
printf("Loop completed. Total iterations: should be %d\n", n);
```

**Quick checks:**
- Does `i` start at the right value? (Usually 0 for arrays)
- Is condition `<` or `<=`? (Usually `<` for arrays)
- Does loop run exactly `n` times for an array of size `n`?

### Problem: Infinite Loop (Loop Never Ends)

**Symptoms:**
- Program hangs
- CPU usage spikes to 100%
- No output or repeated output forever

**Common causes:**
```c
// Cause 1: Condition never becomes false
for (int i = 0; i < 10; i--) {  // i decreases, never reaches 10!
    printf("%d ", i);  // Infinite loop!
}

// Cause 2: Condition always true
for (int i = 0; i != 10; i += 2) {  // If starting at 1, never hits 10 exactly
    printf("%d ", i);  // Infinite if i jumps over 10!
}

// Cause 3: Update doesn't happen
for (int i = 0; i < 10; ) {  // Missing i++
    printf("%d ", i);  // Infinite loop!
}
```

**How to debug:**
1. **Kill the program**: Ctrl+C in terminal
2. **Check update statement**: Is counter actually changing?
3. **Check condition**: Will it ever become false?
4. **Add debug print**: `printf("i = %d\n", i);` at start of loop
5. **Add safety limit**: `if (i > 1000) break;  // Emergency exit`

### Problem: Loop Counter Modified Inside Loop

**Why it's confusing:**
```c
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
    if (i == 5) {
        i = 8;  // Skips 6, 7
    }
}
// Output: 0 1 2 3 4 5 9
// Where did 6, 7, 8 go? Very confusing!
```

**Better approaches:**
```c
// Use break to exit
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
    if (i == 5) break;  // Clear intent: stop here
}

// Use continue to skip
for (int i = 0; i < 10; i++) {
    if (i == 5) continue;  // Clear intent: skip this one
    printf("%d ", i);
}
```

### Problem: Nested Loop Confusion

**Debugging technique:**
```c
// Print both loop counters
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        printf("[i=%d][j=%d] ", i, j);
        // ... your code
    }
    printf("\n");
}
```

**Common mistakes:**
```c
// WRONG: Using same variable name
for (int i = 0; i < 5; i++) {
    for (int i = 0; i < 3; i++) {  // Shadows outer i!
        printf("%d ", i);  // Which i?
    }
}

// CORRECT: Different names
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 3; j++) {
        printf("%d,%d ", i, j);
    }
}
```

## Common Pitfalls

### Modifying Loop Counter Inside Loop

```c
// WRONG: Unpredictable behavior
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
    if (i == 5) {
        i = 8;  // Skips values - confusing!
    }
}

// CORRECT: Use break or adjust condition instead
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
    if (i == 5) {
        break;  // Clear intent to exit
    }
}
```

### Off-By-One Errors

**Why it happens:** Confusing array size with last valid index.

```c
// WRONG: Misses last element
int arr[5] = {10, 20, 30, 40, 50};
//       size = 5, valid indices are 0,1,2,3,4
for (int i = 0; i < 4; i++) {  // Should be i < 5
    printf("%d ", arr[i]);
}
// Output: 10 20 30 40 (missing 50)
```

**What you'll see:** Incomplete output, partial processing, or wrong results.

**How to debug:**
1. **Count expected iterations**: Array of size 5 needs 5 iterations
2. **Check first and last**: Manually verify `i=0` and `i=4` are processed
3. **Print loop counter**:
```c
for (int i = 0; i < 4; i++) {
    printf("i=%d: %d\n", i, arr[i]);
}
// Shows: Only prints i=0,1,2,3 (missing i=4!)
```

**The fix:**
```c
// CORRECT: Loop through all elements
for (int i = 0; i < 5; i++) {  // i < size
    printf("%d ", arr[i]);
}
// Output: 10 20 30 40 50

// BEST: Use sizeof for robustness
int arr[5] = {10, 20, 30, 40, 50};
int size = sizeof(arr) / sizeof(arr[0]);  // Calculate size
for (int i = 0; i < size; i++) {
    printf("%d ", arr[i]);
}
```

**Prevention:**
- Remember: array size `n` means indices `0` to `n-1`
- Use `i < n`, not `i <= n` or `i < n-1`
- Use `sizeof` to calculate size automatically
- Test with small arrays where it's easy to count

### Semicolon After For

```c
// WRONG: Empty loop body!
for (int i = 0; i < 5; i++);  // Semicolon here!
{
    printf("Hello\n");  // Only executes once after loop!
}

// CORRECT: No semicolon after for
for (int i = 0; i < 5; i++) {
    printf("Hello\n");  // Executes 5 times
}
```

### Floating-Point Loop Counters

```c
// RISKY: Floating-point precision issues
for (float f = 0.0f; f != 1.0f; f += 0.1f) {
    printf("%.1f ", f);
}
// May never reach exactly 1.0 due to rounding errors!

// BETTER: Use integer counter
for (int i = 0; i < 10; i++) {
    float f = i * 0.1f;
    printf("%.1f ", f);
}
```

## Exercises

1. **Prime Number Checker**: Write a program that checks if a number is prime by testing divisibility from 2 to n-1.

2. **Fibonacci Sequence**: Print the first n numbers in the Fibonacci sequence (0, 1, 1, 2, 3, 5, 8, 13, ...).

3. **Number Pyramid**: Create a pyramid pattern:
   ```
       1
      121
     12321
    1234321
   123454321
   ```

4. **Sum of Squares**: Calculate the sum of squares from 1² to n².

5. **Perfect Numbers**: Find all perfect numbers between 1 and 1000. A perfect number equals the sum of its proper divisors (e.g., 6 = 1+2+3).

## Key Takeaways

- For loops are best when you know the number of iterations in advance
- Structure: `for (init; condition; update)`
- Loop variable scope is typically limited to the loop (C99 and later)
- All three parts are optional but semicolons are required: `for (;;)`
- Avoid modifying the loop counter inside the loop body
- Watch out for off-by-one errors: `<` vs `<=`
- Never put a semicolon immediately after the for statement
- Nested for loops are useful for 2D patterns, tables, and matrices
- For loops can do everything while loops can, but they're cleaner when counting
