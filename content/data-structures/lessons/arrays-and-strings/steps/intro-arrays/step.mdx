---
id: intro-arrays
title: Introduction to Arrays
order: 1
---

# Introduction to Arrays

An **array** is a collection of elements of the same type stored in **contiguous memory locations**. Arrays provide O(1) random access to elements by their index.

## WHY Arrays Exist

Arrays solve a fundamental problem: storing multiple values of the same type efficiently. Before arrays, programmers had to create separate variables for each value, which is impractical for large datasets.

**Problem without arrays:**

```c
int score1, score2, score3, score4, score5;
score1 = 95;
score2 = 87;
// ... tedious for 1000 scores!
```

**Solution with arrays:**

```c
int scores[1000];
for (int i = 0; i < 1000; i++) {
    scores[i] = calculateScore();
}
```

## HOW Arrays Work

### Memory Layout

When you declare an array, the compiler allocates a **contiguous block** of memory:

```
Memory Address:  0x1000  0x1004  0x1008  0x100C  0x1010
                 +-------+-------+-------+-------+-------+
Array int[5]:    |  95   |  87   |  92   |  78   |  90   |
                 +-------+-------+-------+-------+-------+
Index:             [0]     [1]     [2]     [3]     [4]
```

**WHY contiguous?** Memory addresses are sequential. To access element at index `i`, the computer calculates:

```
address = base_address + (i × element_size_in_bytes)
```

This calculation is a single arithmetic operation → **O(1) access time**.

### Zero-Based Indexing

**WHY index starts at 0 (not 1)?**

The index is an **offset** from the base address:

- Index 0 means "0 bytes from base address" → first element
- Index 1 means "size_of_element bytes from base" → second element
- Index i means "i × size_of_element bytes from base" → (i+1)th element

If indexing started at 1, the formula would be `(i-1) × size`, requiring an extra subtraction.

## Pseudo Code: Array Operations

```
FUNCTION access(array, index):
    // WHY: Direct memory calculation
    address = array.base_address + (index × array.element_size)
    RETURN memory_read(address)

FUNCTION search(array, target):
    // WHY: Must check each element sequentially
    FOR i FROM 0 TO array.length - 1:
        IF array[i] == target:
            RETURN i  // Found
    RETURN -1  // Not found

FUNCTION insert_at_end(array, value):
    IF array.length == array.capacity:
        RETURN false  // Array full
    array[array.length] = value
    array.length = array.length + 1
    RETURN true

FUNCTION delete_at_end(array):
    IF array.length == 0:
        RETURN false
    array.length = array.length - 1
    RETURN true
```

## Time Complexity Analysis

| Operation       | Best Case | Worst Case | WHY                                        |
| --------------- | --------- | ---------- | ------------------------------------------ |
| Access by idx   | O(1)      | O(1)       | Direct memory calculation                  |
| Search          | O(1)      | O(n)       | Best case: first element; worst: not found |
| Insert (end)    | O(1)      | O(n)       | O(1) if space exists; O(n) to resize       |
| Delete (end)    | O(1)      | O(1)       | Just decrement length                      |
| Insert (middle) | O(n)      | O(n)       | Must shift all subsequent elements         |
| Delete (middle) | O(n)      | O(n)       | Must shift all subsequent elements         |

## Pros and Cons

### Pros

| Advantage                   | Explanation                                   |
| --------------------------- | --------------------------------------------- |
| **O(1) Random Access**      | Direct memory calculation, fastest possible   |
| **Cache Friendly**          | Contiguous memory = CPU prefetcher works well |
| **Memory Overhead = 0**     | Only stores data, no pointers/structures      |
| **Simple Implementation**   | Basic concept, easy to understand             |
| **Best for iteration**      | Loop through all elements efficiently         |
| **Predictable Performance** | Always same time for same operation           |

### Cons

| Disadvantage                | Explanation                                      |
| --------------------------- | ------------------------------------------------ |
| **Fixed Size**              | Cannot grow/shrink dynamically (in basic arrays) |
| **Expensive Insert/Delete** | Middle operations require shifting O(n) elements |
| **No Bounds Checking**      | C allows accessing any memory (security risk)    |
| **Wasted Memory**           | Must allocate maximum expected size              |
| **Homogeneous Only**        | All elements must be same type                   |

## When to Use Arrays

### Use Arrays When:

✓ You know the exact size in advance  
✓ You need the fastest possible access by index  
✓ You iterate through all elements sequentially  
✓ Memory is constrained (no overhead)  
✓ You need cache-friendly performance

### Don't Use Arrays When:

✗ Size is unknown and changes frequently  
✗ You frequently insert/delete from the middle  
✗ You need to store different types together  
✗ You need dynamic resizing

## Comparison with Alternatives

| Feature            | Array     | Linked List | Hash Table     |
| ------------------ | --------- | ----------- | -------------- |
| Access by Index    | O(1)      | O(n)        | N/A            |
| Search             | O(n)      | O(n)        | O(1) avg       |
| Insert (beginning) | O(n)      | O(1)        | O(1)           |
| Insert (end)       | O(1)\*    | O(1)        | O(1)           |
| Insert (middle)    | O(n)      | O(1)\*\*    | O(1)           |
| Memory Overhead    | None      | 1 ptr/node  | Hash + buckets |
| Cache Friendly     | Excellent | Poor        | Medium         |

\*With reserved capacity  
\*\*With pointer to position

## Static vs Dynamic Arrays

### Static Arrays (Compile-Time)

```c
int numbers[100];           // Fixed at 100 elements
double data[1000][1000];    // 2D array, 1 million doubles
char text[256];             // String buffer
```

**Characteristics:**

- Size determined at compile time
- Memory allocated on stack (small arrays) or static section
- No runtime allocation overhead
- Maximum size must be known

**When to use:**

- Size is truly known at compile time
- Size is small (< few thousand elements)
- Performance is critical

### Dynamic Arrays (Runtime-Allocated)

```c
int *numbers = malloc(100 * sizeof(int));
if (numbers == NULL) {
    // Handle allocation failure
    fprintf(stderr, "Memory allocation failed\n");
    exit(1);
}

// Use array...
numbers[0] = 42;

// Resize when needed
int *larger = realloc(numbers, 200 * sizeof(int));
if (larger == NULL) {
    // realloc failed, original numbers still valid
    free(numbers);
    exit(1);
}
numbers = larger;

// Don't forget to free!
free(numbers);
```

**Characteristics:**

- Size determined at runtime
- Memory allocated on heap
- Can resize with realloc()
- Must manually free() when done

**Memory Layout After Resize:**

```
Before realloc(200):           After realloc(200):
Address                         Address
0x2000: [0]                     0x2000: [0]
0x2004: [1]                     0x2004: [1]
...                             ...
0x20FC: [99]                    0x20FC: [99]
                                 0x2100: [100]  ← New space
                                 ...
                                 0x21FC: [199] ← New space
```

**Resize Strategy (Amortized Analysis):**

When array is full, typically **double** the capacity:

- New capacity = 2 × old capacity
- This ensures O(1) amortized cost per insertion

**Amortized Cost Proof:**

```
Total cost to insert n elements:
- Each element copied at most log₂(n) times
- 1 + 2 + 4 + 8 + ... + n = 2n - 1
- Average per insert = (2n-1)/n ≈ O(1)
```

## Common Array Patterns

### 1. Two Pointers

```pseudo
FUNCTION two_sum_sorted(array, target):
    left = 0
    right = array.length - 1
    WHILE left < right:
        sum = array[left] + array[right]
        IF sum == target:
            RETURN (left, right)
        ELSE IF sum < target:
            left = left + 1
        ELSE:
            right = right - 1
    RETURN null
```

### 2. Sliding Window

```pseudo
FUNCTION max_sum_subarray(array, k):
    IF array.length < k:
        RETURN -1

    window_sum = sum of first k elements
    max_sum = window_sum

    FOR i FROM k TO array.length - 1:
        window_sum = window_sum - array[i-k] + array[i]
        max_sum = max(max_sum, window_sum)

    RETURN max_sum
```

### 3. Prefix Sums

```pseudo
FUNCTION build_prefix(array):
    prefix[0] = array[0]
    FOR i FROM 1 TO array.length - 1:
        prefix[i] = prefix[i-1] + array[i]
    RETURN prefix

FUNCTION range_sum(prefix, left, right):
    IF left == 0:
        RETURN prefix[right]
    RETURN prefix[right] - prefix[left-1]
```

## Key Takeaways

1. **Arrays excel at access by index** - O(1) because of direct memory calculation
2. **Contiguous memory = cache friendly** - Hardware prefetcher works optimally
3. **Insert/delete in middle is expensive** - Must shift O(n) elements
4. **Resize is expensive** - Use amortized analysis; double capacity strategy
5. **Know your size** - Best when size is known or stable
