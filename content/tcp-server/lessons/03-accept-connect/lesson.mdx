---
id: 03-accept-connect
title: 'Accept and Connect'
description: Master the connection establishment processâ€”learn the three-way handshake, accept connections on the server side, and connect as a client.
type: lesson
order: 3
---

# Accept and Connect

Now we can accept incoming connections! This lesson covers the famous three-way handshake and implementing both server-side `accept()` and client-side `connect()`.

## The Three-Way Handshake

Every TCP connection starts with a three-way handshake:

```
Client                      Server
   |                          |
   |      [Closed]            |    [Listening]
   |                          |
   |---- SYN (seq=x) -------> |    Client sends SYN
   |                          |
   |<--- SYN+ACK (seq=y,ack=x+1) --- |    Server responds with SYN+ACK
   |                          |
   |---- ACK (ack=y+1) -----> |    Client sends final ACK
   |                          |
   |    [Established]         |    [Established]
```

1. **SYN**: Client sends SYN with a sequence number
2. **SYN+ACK**: Server acknowledges with ACK and sends its own SYN
3. **ACK**: Client acknowledges the server's SYN

After this exchange, both sides have confirmed they can send and receive.

## The accept() Function

The `accept()` function extracts the first connection request from the queue and returns a **new socket** for communicating with that client:

```c
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

- `sockfd`: The listening socket
- `addr`: Filled with the client's address (can be NULL)
- `addrlen`: Size of addr structure (can be NULL)
- **Returns**: New socket fd for this connection, or -1 on error

```c
struct sockaddr_in client_addr;
socklen_t client_len = sizeof(client_addr);

int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);

if (client_fd == -1) {
    perror("accept failed");
    return 1;
}

printf("Client connected from %s:%d\n",
       inet_ntoa(client_addr.sin_addr),
       ntohs(client_addr.sin_port));
```

**Important:** `accept()` returns a **new socket**. The original `server_fd` remains the listening socket.

## The connect() Function

Clients use `connect()` to establish a connection with the server:

```c
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

```c
struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(8080);
inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);

if (connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
    perror("connect failed");
    return 1;
}

printf("Connected to server!\n");
```

## Complete Server Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

#define PORT 8080

int main() {
    // Create socket
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);

    // Address reuse
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // Bind
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    bind(server_fd, (struct sockaddr*)&address, sizeof(address));

    // Listen
    listen(server_fd, 5);
    printf("Server listening on port %d\n", PORT);

    // Accept a connection
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);

    printf("Accepted connection from %s:%d\n",
           inet_ntoa(client_addr.sin_addr),
           ntohs(client_addr.sin_port));

    // Clean up
    close(client_fd);
    close(server_fd);
    return 0;
}
```

## Summary

In this lesson, you learned:

- The three-way handshake process
- How `accept()` extracts connections from the queue
- How `connect()` establishes connections from the client side
- The difference between the listening socket and connected sockets

## Next Steps

In the next lesson, we'll send and receive actual data over our connection!
