---
id: recursion-basics
title: Recursion Basics
order: 1
---

# Recursion Basics

A **recursive function** calls itself to solve a problem by breaking it into smaller, similar subproblems.

## WHY Recursion Exists

Recursion naturally models problems with **recursive structure**:

**Mathematical examples:**

```
Factorial: n! = n Ã— (n-1)!
Fibonacci: F(n) = F(n-1) + F(n-2)
Sum: sum(n) = n + sum(n-1)
```

**Real-world examples:**

- **Tree traversal**: Visit node, then visit subtrees
- **Directory structure**: Process folder, then process subfolders
- **Fractals**: Self-similar patterns at different scales
- **Divide and conquer**: Split problem, solve parts, combine

**WHY recursion works:**
If you can solve the smaller problem, you can solve the bigger one.

## HOW Recursion Works

### The Call Stack

When a function calls itself, each call gets its own **stack frame**:

```
Stack Frames (for factorial(4)):

factorial(1) frame
  returns 1
factorial(2) frame
  returns 2 * 1 = 2
factorial(3) frame
  returns 3 * 2 = 6
factorial(4) frame
  returns 4 * 6 = 24
```

**Each frame contains:**

- Function parameters
- Local variables
- Return address
- Stack frame pointer

### Visual Execution Trace

```
factorial(4)
    |
    +---> n = 4, not base case
    |     calls factorial(3)
    |
    +---> n = 3, not base case
    |     calls factorial(2)
    |
    +---> n = 2, not base case
    |     calls factorial(1)
    |
    +---> n = 1, BASE CASE!
    |     returns 1
    |
    <--- returns 1 to caller
    |
    <--- returns 2 to caller
    |
    <--- returns 6 to caller
    |
    <--- returns 24 to caller
    |
Result: 24
```

## Pseudo Code: Core Recursion

### Anatomy of Recursion

```
FUNCTION recursive_function(problem):
    // BASE CASE: The smallest problem, solved directly
    IF problem is small enough:
        RETURN solution_to_small_problem

    // RECURSIVE CASE: Break into smaller problems
    smaller_problems = split_problem(problem)

    FOR each smaller_problem:
        solution = recursive_function(smaller_problem)
        solutions.append(solution)

    // COMBINE: Solve original from smaller solutions
    combined_solution = combine(solutions)
    RETURN combined_solution
```

### Key Components

**1. Base Case:**

- Smallest instance of the problem
- Solved directly without recursion
- **MUST exist** to prevent infinite recursion
- Returns a value that can be combined

**2. Recursive Case:**

- Breaks problem into smaller instances
- Calls itself with smaller problem
- **MUST make progress** toward base case

**3. Combine Step:**

- Combines solutions from recursive calls
- Not always explicit (sometimes implicit in return)

## Recursion Examples

### Example 1: Countdown

```
FUNCTION countdown(n):
    IF n <= 0:
        PRINT "Blastoff!"
        RETURN

    PRINT n
    countdown(n - 1)

Execution trace for countdown(3):
1. n=3, not <= 0, print 3, call countdown(2)
2. n=2, not <= 0, print 2, call countdown(1)
3. n=1, not <= 0, print 1, call countdown(0)
4. n=0, <= 0, print "Blastoff!", return
```

### Example 2: Sum of First n Numbers

```
FUNCTION sum(n):
    // Base case
    IF n <= 0:
        RETURN 0

    // Recursive case + combine
    RETURN n + sum(n - 1)

Execution trace for sum(4):
sum(4) = 4 + sum(3)
       = 4 + (3 + sum(2))
       = 4 + (3 + (2 + sum(1)))
       = 4 + (3 + (2 + (1 + sum(0))))
       = 4 + (3 + (2 + (1 + 0)))
       = 4 + 3 + 2 + 1 + 0
       = 10
```

### Example 3: Count Digits

```
FUNCTION count_digits(n):
    IF n < 10:
        RETURN 1

    RETURN 1 + count_digits(n / 10)

Execution trace for count_digits(1234):
count_digits(1234) = 1 + count_digits(123)
                    = 1 + (1 + count_digits(12))
                    = 1 + (1 + (1 + count_digits(1)))
                    = 1 + (1 + (1 + 1))
                    = 4
```

## Common Mistakes

### Mistake 1: No Base Case

```
// INFINITE RECURSION - Will crash with stack overflow!
FUNCTION bad_factorial(n):
    RETURN n * bad_factorial(n - 1)  // Never stops!
```

**WHY bad?** Each call pushes a new frame, stack eventually overflows.

### Mistake 2: No Progress

```
// INFINITE RECURSION - n keeps increasing!
FUNCTION bad_sum(n):
    IF n == 0: RETURN 0
    RETURN n + bad_sum(n + 1)  // n increases, never reaches 0!
```

**WHY bad?** Condition n == 0 will never be true.

### Mistake 3: Wrong Base Case

```
// WRONG - Misses some cases!
FUNCTION fibonacci(n):
    IF n == 1: RETURN 1  // What about n=0?
    RETURN fibonacci(n - 1) + fibonacci(n - 2)
```

**WHY bad?** fibonacci(0) will cause infinite recursion.

### Mistake 4: Stack Overflow from Too Many Calls

```
FUNCTION count_to_million():
    count_to_million() + 1  // 1 million frames = stack overflow
```

**WHY bad?** Stack has limited size (typically 8MB on most systems).

## Recursion vs Iteration

### When Recursion is Better

| Problem Type        | Example                              |
| ------------------- | ------------------------------------ |
| Tree-like structure | Tree traversal, file system          |
| Divide and conquer  | Merge sort, quicksort, FFT           |
| Mathematical        | Factorial, Fibonacci, combinatorics  |
| Backtracking        | N-Queens, Sudoku, puzzles            |
| Natural recursion   | HTML DOM, organizational hierarchies |

### When Iteration is Better

| Problem Type         | Example                           |
| -------------------- | --------------------------------- |
| Simple loops         | Array traversal, counting         |
| Performance critical | Stack frame overhead is expensive |
| Deep recursion risk  | Could exceed stack size           |
| Tail recursion       | Can be optimized to iteration     |

### Conversion Pattern

```
// Recursive
FUNCTION recursive_solution(problem):
    IF base_case: RETURN result
    RETURN combine(solution, recursive_solution(smaller_problem))

// Iterative (using stack)
FUNCTION iterative_solution(problem):
    stack = NEW Stack
    stack.push(problem)
    result = null

    WHILE stack not empty:
        current = stack.pop()
        IF base_case(current):
            result = combine(result, current)
        ELSE:
            stack.push(larger_subproblem(current))
            stack.push(smaller_subproblem(current))

    RETURN result
```

## Tail Recursion

**Tail recursion** = recursive call is the last operation:

```
// TAIL RECURSIVE - Optimizable
FUNCTION factorial_tail(n, acc):
    IF n <= 1: RETURN acc
    RETURN factorial_tail(n - 1, n * acc)

// NOT TAIL RECURSIVE - Must return from recursive call
FUNCTION factorial(n):
    IF n <= 1: RETURN 1
    RETURN n * factorial(n - 1)  // Multiplication after return
```

**WHY tail recursion matters:**

- Some compilers optimize tail recursion to iteration
- Eliminates stack frame accumulation
- Transforms to: `acc = acc * n; n = n - 1;`

## Key Takeaways

1. **Recursion breaks problems** - Solve smaller instances, combine results
2. **Base case is essential** - Prevents infinite recursion
3. **Each call must progress** - Toward the base case
4. **Stack frame overhead** - Each call uses memory
5. **Natural for trees/div-conquer** - Matches problem structure
6. **Tail recursion optimization** - Can become iteration
7. **Can always convert to iteration** - Using explicit stack
