---
id: 01-read-write
title: 'Read and Write Operations'
order: 1
---

# Read and Write Operations

Let's explore the basic read and write operations using `read()`, `write()`, `recv()`, and `send()`.

## read() and write()

These are the simplest file I/O functions, inherited from Unix file semantics:

```c
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

```c
// Read from socket
char buffer[1024];
ssize_t n = read(client_fd, buffer, sizeof(buffer) - 1);

if (n > 0) {
    buffer[n] = '\0';
    printf("Read %zd bytes: %s\n", n, buffer);
}

// Write to socket
const char *msg = "Response";
ssize_t written = write(client_fd, msg, strlen(msg));
```

## recv() and send()

These are socket-specific and support flags:

```c
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

**Useful flags:**

| Flag           | Meaning                     |
| -------------- | --------------------------- |
| `MSG_NOSIGNAL` | Don't send SIGPIPE on error |
| `MSG_OOB`      | Send/recv out-of-band data  |
| `MSG_DONTWAIT` | Non-blocking I/O            |
| `MSG_MORE`     | More data coming (TCP cork) |

```c
// Send without SIGPIPE
ssize_t n = send(fd, buf, len, MSG_NOSIGNAL);

// Receive with non-blocking hint
ssize_t n = recv(fd, buf, len, MSG_DONTWAIT);
```

## SIGPIPE Explained

If you write to a closed socket, your process receives `SIGPIPE`. Default behavior: terminate!

```c
// Prevent SIGPIPE
signal(SIGPIPE, SIG_IGN);

// Or use MSG_NOSIGNAL flag
send(fd, buf, len, MSG_NOSIGNAL);
```

## Echo Using read/write

```c
#include <stdio.h>
#include <unistd.h>

void handle_client(int client_fd) {
    char buffer[1024];

    while (1) {
        ssize_t n = read(client_fd, buffer, sizeof(buffer));

        if (n <= 0) {
            if (n == 0) printf("Client disconnected\n");
            else perror("read");
            break;
        }

        // Echo back
        if (write(client_fd, buffer, n) == -1) {
            perror("write");
            break;
        }
    }

    close(client_fd);
}
```
