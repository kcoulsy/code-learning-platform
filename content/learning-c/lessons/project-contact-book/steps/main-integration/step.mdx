---
title: "Step 6: Main Integration"
description: "Bring all modules together into a complete application"
order: 6
---

# Step 6: Main Integration

You've built all the individual modules. Now it's time to bring everything together into a complete, working contact book application!

## Overview

In this step, you'll:
- Create the main.c entry point
- Implement the main program loop
- Connect all modules together
- Handle initialization and cleanup
- Create a build system (Makefile or script)
- Test the complete application

## Main Program Structure

### main.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "contact.h"
#include "storage.h"
#include "ui.h"

#define CONTACTS_FILE "data/contacts.txt"

int main(int argc, char *argv[]) {
    // 1. Initialize
    ContactBook book;
    contactbook_init(&book);

    // 2. Load existing contacts
    printf("Loading contacts from %s...\n", CONTACTS_FILE);
    int loaded = storage_load(&book, CONTACTS_FILE);

    if (loaded > 0) {
        printf("Loaded %d contact(s).\n", loaded);
    } else if (loaded == 0) {
        printf("Starting with empty contact book.\n");
    } else {
        printf("Warning: Failed to load contacts.\n");
    }

    // 3. Main program loop
    int running = 1;
    int auto_save = 1;  // Track if we should save on exit

    while (running) {
        int choice = ui_show_menu();

        switch (choice) {
            case 1:  // Add contact
                ui_add_contact(&book);
                break;

            case 2:  // List contacts
                ui_list_contacts(&book);
                break;

            case 3:  // Search contacts
                ui_search_contacts(&book);
                break;

            case 4:  // Delete contact
                ui_delete_contact(&book);
                break;

            case 5:  // Save and exit
                printf("\nSaving contacts...\n");
                if (storage_save(&book, CONTACTS_FILE) == 0) {
                    printf("Contacts saved successfully.\n");
                } else {
                    printf("Error: Failed to save contacts.\n");
                }
                running = 0;
                break;

            case 6:  // Exit without saving
                if (ui_confirm("Exit without saving? (y/n): ")) {
                    auto_save = 0;
                    running = 0;
                }
                break;

            default:
                ui_show_error("Invalid choice. Please enter 1-6.");
                break;
        }

        // Pause before showing menu again
        if (running) {
            printf("\nPress Enter to continue...");
            getchar();
        }
    }

    // 4. Auto-save if enabled
    if (auto_save) {
        // Already saved, or save here if you want auto-save on all exits
    }

    // 5. Cleanup
    printf("\nCleaning up...\n");
    contactbook_destroy(&book);

    printf("Goodbye!\n");
    return 0;
}
```

**Your Task**: Review and enhance this main loop.

**Enhancements to Consider**:
1. Command-line arguments (e.g., `./contact-book --file mycontacts.txt`)
2. Auto-save after each operation
3. Statistics on exit (number of contacts added/deleted this session)
4. Crash recovery (periodic auto-save)

## Command-Line Arguments

### Basic Argument Parsing

```c
int main(int argc, char *argv[]) {
    const char *contacts_file = CONTACTS_FILE;  // Default

    // Parse arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--file") == 0 || strcmp(argv[i], "-f") == 0) {
            if (i + 1 < argc) {
                contacts_file = argv[i + 1];
                i++;  // Skip next argument
            } else {
                fprintf(stderr, "Error: --file requires a filename\n");
                return 1;
            }
        } else if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            printf("Usage: %s [OPTIONS]\n", argv[0]);
            printf("\nOptions:\n");
            printf("  -f, --file FILE    Use FILE for contact storage\n");
            printf("  -h, --help         Show this help message\n");
            return 0;
        } else {
            fprintf(stderr, "Error: Unknown argument '%s'\n", argv[i]);
            fprintf(stderr, "Use --help for usage information\n");
            return 1;
        }
    }

    // Rest of main() using contacts_file
    // ...
}
```

### Usage Examples

```bash
./contact-book                          # Use default file
./contact-book --file personal.txt      # Use custom file
./contact-book -f work.txt              # Short form
./contact-book --help                   # Show help
```

## Build System

### Option 1: Simple Compilation Script

Create `build.sh` (Linux/Mac):

```bash
#!/bin/bash

echo "Building contact-book..."

gcc -Wall -Wextra -std=c99 \
    -o contact-book \
    main.c contact.c storage.c ui.c

if [ $? -eq 0 ]; then
    echo "Build successful!"
    echo "Run with: ./contact-book"
else
    echo "Build failed!"
    exit 1
fi
```

Or `build.bat` (Windows):

```batch
@echo off
echo Building contact-book...

gcc -Wall -Wextra -std=c99 -o contact-book.exe main.c contact.c storage.c ui.c

if %ERRORLEVEL% EQU 0 (
    echo Build successful!
    echo Run with: contact-book.exe
) else (
    echo Build failed!
    exit /b 1
)
```

Make executable:
```bash
chmod +x build.sh
./build.sh
```

### Option 2: Makefile (Recommended)

Create `Makefile`:

```makefile
# Compiler and flags
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
LDFLAGS =

# Target executable
TARGET = contact-book

# Source files
SRCS = main.c contact.c storage.c ui.c

# Object files (replace .c with .o)
OBJS = $(SRCS:.c=.o)

# Header files (for dependencies)
HEADERS = contact.h storage.h ui.h

# Default target
all: $(TARGET)

# Link object files to create executable
$(TARGET): $(OBJS)
	$(CC) $(OBJS) $(LDFLAGS) -o $(TARGET)
	@echo "Build successful!"

# Compile source files to object files
%.o: %.c $(HEADERS)
	$(CC) $(CFLAGS) -c $< -o $@

# Clean build artifacts
clean:
	rm -f $(OBJS) $(TARGET)
	@echo "Clean complete."

# Run the program
run: $(TARGET)
	./$(TARGET)

# Run tests
test: test_contact test_storage
	@echo "Running tests..."
	./test_contact
	./test_storage

test_contact: test_contact.o contact.o
	$(CC) test_contact.o contact.o -o test_contact

test_storage: test_storage.o contact.o storage.o
	$(CC) test_storage.o contact.o storage.o -o test_storage

# Create data directory
setup:
	mkdir -p data
	@echo "Created data directory."

# Install (optional)
install: $(TARGET)
	cp $(TARGET) /usr/local/bin/
	@echo "Installed to /usr/local/bin/"

# Phony targets (not files)
.PHONY: all clean run test setup install
```

**Usage**:
```bash
make           # Build the program
make run       # Build and run
make clean     # Remove build artifacts
make test      # Build and run tests
make setup     # Create data directory
```

### Build Instructions for Users

Create a `BUILD.md` or `README.md`:

```markdown
# Contact Book - Build Instructions

## Requirements
- C compiler (GCC or Clang)
- Make (optional, for Makefile)

## Building

### Using Make (recommended)
```bash
make
```

### Using build script
```bash
chmod +x build.sh
./build.sh
```

### Manual compilation
```bash
gcc -Wall -Wextra -std=c99 -o contact-book main.c contact.c storage.c ui.c
```

## Running
```bash
./contact-book
```

## Testing
```bash
make test
```

## Installation
```bash
sudo make install
```
```

## Directory Structure

Your final project structure should look like:

```
contact-book/
├── src/
│   ├── main.c
│   ├── contact.h
│   ├── contact.c
│   ├── storage.h
│   ├── storage.c
│   ├── ui.h
│   └── ui.c
├── tests/
│   ├── test_contact.c
│   └── test_storage.c
├── data/
│   └── contacts.txt (created at runtime)
├── Makefile
├── build.sh
├── README.md
└── BUILD.md
```

**Your Task**: Organize your files into this structure (or similar).

## Integration Testing

### Test Complete Workflows

Create `test_integration.sh`:

```bash
#!/bin/bash

echo "=== Integration Tests ==="
echo ""

# Test 1: Build succeeds
echo "Test 1: Building application..."
make clean && make
if [ $? -ne 0 ]; then
    echo "FAILED: Build error"
    exit 1
fi
echo "PASSED"
echo ""

# Test 2: Help message works
echo "Test 2: Help message..."
./contact-book --help > /dev/null
if [ $? -ne 0 ]; then
    echo "FAILED: Help command error"
    exit 1
fi
echo "PASSED"
echo ""

# Test 3: Custom file location works
echo "Test 3: Custom file location..."
echo "5" | ./contact-book --file test_contacts.txt > /dev/null
if [ ! -f test_contacts.txt ]; then
    echo "FAILED: File not created"
    exit 1
fi
rm test_contacts.txt
echo "PASSED"
echo ""

echo "All integration tests passed!"
```

### Manual Testing Checklist

Test the complete application end-to-end:

- [ ] Program starts without errors
- [ ] Menu displays correctly
- [ ] Can add a contact with all fields
- [ ] Can add a contact with only name
- [ ] Can list contacts
- [ ] Contacts display with proper formatting
- [ ] Can search for existing contact
- [ ] Search is case-insensitive
- [ ] Can delete a contact
- [ ] Deletion requires confirmation
- [ ] Can cancel deletion
- [ ] Save and exit saves to file
- [ ] Exit without saving doesn't modify file
- [ ] Restarting loads saved contacts
- [ ] Invalid menu choices show error
- [ ] Can handle empty contact book
- [ ] Can handle maximum contacts (stress test)

## Error Handling Integration

### Centralized Error Handling

Consider adding a global error handler:

```c
typedef enum {
    ERR_NONE = 0,
    ERR_OUT_OF_MEMORY,
    ERR_FILE_NOT_FOUND,
    ERR_FILE_PERMISSION,
    ERR_INVALID_INPUT,
    ERR_BOOK_FULL
} ErrorCode;

void handle_error(ErrorCode code) {
    switch (code) {
        case ERR_OUT_OF_MEMORY:
            fprintf(stderr, "Fatal: Out of memory\n");
            exit(1);
        case ERR_FILE_PERMISSION:
            fprintf(stderr, "Error: Permission denied\n");
            break;
        // ... handle other errors
        default:
            break;
    }
}
```

## Performance Considerations

### For Large Contact Lists

If you expect to handle thousands of contacts:

1. **Use efficient data structures**: Consider a hash table or binary search tree
2. **Lazy loading**: Only load contacts as needed
3. **Indexed search**: Create an index file for faster searching
4. **Pagination**: Don't display all contacts at once

### Memory Management

Check for leaks with the full application:

```bash
valgrind --leak-check=full ./contact-book
# Run through various operations
# Choose option 5 to exit
```

## Deployment

### Creating a Release

1. **Version your code**: Add a version number
   ```c
   #define VERSION "1.0.0"
   ```

2. **Create release script** (`release.sh`):
   ```bash
   #!/bin/bash
   VERSION="1.0.0"

   make clean
   make

   mkdir -p release
   cp contact-book release/
   cp README.md release/

   tar -czf contact-book-v${VERSION}.tar.gz release/
   echo "Release package created: contact-book-v${VERSION}.tar.gz"
   ```

3. **Test the release package**:
   ```bash
   tar -xzf contact-book-v1.0.0.tar.gz
   cd release
   ./contact-book
   ```

## Common Integration Issues

### Issue: Linker Errors

**Problem**: Undefined reference to functions

**Solution**: Make sure all `.c` files are included in compilation:
```bash
gcc main.c contact.c storage.c ui.c  # Include ALL source files
```

### Issue: Header File Not Found

**Problem**: `fatal error: contact.h: No such file or directory`

**Solution**: Headers must be in same directory or use `-I` flag:
```bash
gcc -I./include main.c ...
```

### Issue: Segmentation Fault on Startup

**Problem**: Program crashes immediately

**Debug Steps**:
1. Run with gdb: `gdb ./contact-book`
2. Type `run`
3. When it crashes, type `backtrace`
4. Check the line where it failed

**Common Causes**:
- Uninitialized pointer
- Forgot to call `contactbook_init()`
- NULL pointer dereference

## Milestone Checklist

- [ ] main.c implements complete program flow
- [ ] All modules are properly included
- [ ] Build system (Makefile or script) works
- [ ] Program compiles without warnings
- [ ] All menu options work correctly
- [ ] Data persists between runs
- [ ] No memory leaks (valgrind clean)
- [ ] Help/usage information available
- [ ] Error handling throughout
- [ ] Code is organized and documented
- [ ] README.md with instructions exists
- [ ] Manual testing checklist completed

## Next Step

Congratulations! Your contact book application is now complete. Move on to **Step 7: Testing & Refinement** to polish your application and make it production-ready.

---

**Pro Tip**: Keep your main() function clean and simple. It should orchestrate the modules, not contain business logic. If main() gets too long, extract functionality into separate functions!
