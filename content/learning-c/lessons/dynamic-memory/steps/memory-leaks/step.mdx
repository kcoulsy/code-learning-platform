---
title: "Memory Leaks"
order: 5
---

# Memory Leaks

A memory leak occurs when allocated memory is never freed, causing your program to consume more and more memory over time. Understanding how to detect, prevent, and fix memory leaks is crucial for writing robust C programs.

## What is a Memory Leak?

A memory leak happens when you allocate memory on the heap but lose the pointer to it before freeing it, making the memory permanently inaccessible but still allocated.

```c
#include <stdio.h>
#include <stdlib.h>

void leak_example() {
    int *ptr = malloc(sizeof(int));  // Allocate memory
    *ptr = 42;
    // Function returns without freeing ptr
    // Memory is leaked - we can't access or free it anymore
}

int main() {
    for (int i = 0; i < 1000; i++) {
        leak_example();  // Leaks 4 bytes per call = 4000 bytes total
    }
    printf("Leaked 4000 bytes!\n");
    return 0;
}
```

## Common Causes of Memory Leaks

### 1. Forgetting to Free

The most basic type of leak:

```c
#include <stdio.h>
#include <stdlib.h>

void simple_leak() {
    int *data = malloc(100 * sizeof(int));
    if (data == NULL) return;

    // Use data...
    for (int i = 0; i < 100; i++) {
        data[i] = i;
    }

    // Oops! Forgot to free(data)
}

int main() {
    simple_leak();
    return 0;
}
```

### 2. Losing Pointer Before Freeing

```c
#include <stdio.h>
#include <stdlib.h>

void lost_pointer() {
    int *ptr = malloc(sizeof(int));
    if (ptr == NULL) return;

    *ptr = 10;

    // LEAK! Overwrote pointer without freeing
    ptr = malloc(sizeof(int));
    if (ptr != NULL) {
        *ptr = 20;
        free(ptr);  // Only frees second allocation
    }
    // First allocation is leaked
}

int main() {
    lost_pointer();
    return 0;
}
```

### 3. Early Return Without Cleanup

```c
#include <stdio.h>
#include <stdlib.h>

int process_file(const char *filename) {
    char *buffer = malloc(1024);
    if (buffer == NULL) {
        return -1;
    }

    FILE *f = fopen(filename, "r");
    if (f == NULL) {
        // LEAK! Forgot to free buffer before returning
        return -1;
    }

    // Process file...

    fclose(f);
    free(buffer);
    return 0;
}

// FIXED VERSION
int process_file_fixed(const char *filename) {
    char *buffer = malloc(1024);
    if (buffer == NULL) {
        return -1;
    }

    FILE *f = fopen(filename, "r");
    if (f == NULL) {
        free(buffer);  // Don't forget to free!
        return -1;
    }

    // Process file...

    fclose(f);
    free(buffer);
    return 0;
}

int main() {
    process_file("nonexistent.txt");  // Leaks
    process_file_fixed("nonexistent.txt");  // No leak
    return 0;
}
```

### 4. Reassignment in Loops

```c
#include <stdio.h>
#include <stdlib.h>

void loop_leak() {
    int *ptr = NULL;

    for (int i = 0; i < 10; i++) {
        ptr = malloc(sizeof(int));  // LEAK! Loses previous ptr
        if (ptr != NULL) {
            *ptr = i;
        }
    }

    free(ptr);  // Only frees last allocation, 9 are leaked
}

// FIXED VERSION
void loop_fixed() {
    for (int i = 0; i < 10; i++) {
        int *ptr = malloc(sizeof(int));
        if (ptr != NULL) {
            *ptr = i;
            // Use ptr...
            free(ptr);  // Free each allocation
        }
    }
}

int main() {
    loop_leak();
    loop_fixed();
    return 0;
}
```

## Detecting Memory Leaks

### Method 1: Manual Tracking

```c
#include <stdio.h>
#include <stdlib.h>

// Global counters for debugging
static size_t total_allocated = 0;
static size_t total_freed = 0;
static int allocation_count = 0;

void *debug_malloc(size_t size, const char *file, int line) {
    void *ptr = malloc(size);
    if (ptr != NULL) {
        total_allocated += size;
        allocation_count++;
        printf("MALLOC: %zu bytes at %s:%d (total: %zu)\n",
               size, file, line, total_allocated);
    }
    return ptr;
}

void debug_free(void *ptr, size_t size, const char *file, int line) {
    if (ptr != NULL) {
        free(ptr);
        total_freed += size;
        allocation_count--;
        printf("FREE:   %zu bytes at %s:%d (total freed: %zu)\n",
               size, file, line, total_freed);
    }
}

void report_memory() {
    printf("\n=== MEMORY REPORT ===\n");
    printf("Total allocated: %zu bytes\n", total_allocated);
    printf("Total freed:     %zu bytes\n", total_freed);
    printf("Leaked:          %zu bytes\n", total_allocated - total_freed);
    printf("Active allocs:   %d\n", allocation_count);
}

#define MALLOC(size) debug_malloc(size, __FILE__, __LINE__)
#define FREE(ptr, size) debug_free(ptr, size, __FILE__, __LINE__)

int main() {
    int *p1 = MALLOC(sizeof(int));
    int *p2 = MALLOC(10 * sizeof(int));
    int *p3 = MALLOC(sizeof(int));

    if (p1) *p1 = 10;
    if (p2) p2[0] = 20;
    if (p3) *p3 = 30;

    FREE(p1, sizeof(int));
    FREE(p2, 10 * sizeof(int));
    // Intentionally not freeing p3 to show leak

    report_memory();

    return 0;
}
```

### Method 2: Using Valgrind (Complete Workflow)

**Valgrind** is the industry-standard tool for detecting memory leaks in C programs.

#### Step-by-Step Valgrind Workflow

**1. Write test program:**
```c
#include <stdio.h>
#include <stdlib.h>

void create_leak() {
    int *data = malloc(100 * sizeof(int));
    // Intentionally not freeing
}

int main() {
    create_leak();

    int *arr = malloc(10 * sizeof(int));
    if (arr != NULL) {
        for (int i = 0; i < 10; i++) {
            arr[i] = i;
        }
        free(arr);  // This one is freed
    }

    printf("Done\n");
    return 0;
}
```

**2. Compile with debug symbols:**
```bash
gcc -g -O0 -o program program.c
# -g: include debug symbols (shows line numbers)
# -O0: disable optimizations (easier to debug)
```

**3. Run with Valgrind:**
```bash
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes -v ./program
```

**4. Read the output:**
```
==12345== Memcheck, a memory error detector
==12345== Command: ./program
==12345==
Done
==12345==
==12345== HEAP SUMMARY:
==12345==     in use at exit: 400 bytes in 1 blocks
==12345==   total heap usage: 2 allocs, 1 frees, 440 bytes allocated
==12345==
==12345== 400 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x40051B: create_leak (program.c:5)      ← Line where leak occurred!
==12345==    by 0x400545: main (program.c:11)            ← Called from main
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 400 bytes in 1 blocks      ← Clear leak
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==       possibly lost: 0 bytes in 0 blocks
==12345==     still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
==12345==
==12345== ERROR SUMMARY: 1 errors from 1 contexts
```

**5. Understand leak categories:**

- **definitely lost**: Clear leak - memory you can never access again
- **indirectly lost**: Memory pointed to by definitely lost blocks (e.g., linked list nodes)
- **possibly lost**: Pointer to middle of block (might be false positive)
- **still reachable**: Memory still pointed to at exit (not technically a leak, but suspicious)

**6. Fix the leak:**
```c
void create_leak_fixed() {
    int *data = malloc(100 * sizeof(int));
    if (data != NULL) {
        // Use data...
        free(data);  // Fixed!
    }
}
```

**7. Verify fix:**
```bash
valgrind --leak-check=full ./program
```

Expected output:
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 2 allocs, 2 frees, 440 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
==12345==
==12345== ERROR SUMMARY: 0 errors from 0 contexts
```

#### Advanced Valgrind Techniques

**Leak checking in long-running programs:**
```bash
# Generate suppressions for known safe "leaks" (like in libraries)
valgrind --leak-check=full --gen-suppressions=all ./program 2>&1 | grep -A 20 "suppression:"
```

**Finding leak patterns:**
```bash
# Group similar leaks
valgrind --leak-check=full --leak-resolution=high ./program
```

**Checking specific functions:**
```c
#include <valgrind/valgrind.h>

void check_leaks_here() {
    VALGRIND_DO_LEAK_CHECK;  // Request leak check at this point
}
```

**Common Valgrind output patterns:**

**Pattern 1: Simple leak**
```
400 bytes in 1 blocks are definitely lost
    at malloc (program.c:10)
```
→ Single allocation that wasn't freed

**Pattern 2: Loop leak**
```
4000 bytes in 1000 blocks are definitely lost
    at malloc (program.c:15)
    at process_item (program.c:20)
    at main (program.c:50)
```
→ Leak in loop - each iteration leaks one block

**Pattern 3: Conditional leak**
```
100 bytes in 1 blocks are definitely lost
    at malloc (program.c:25)
    at error_handler (program.c:30)
```
→ Error path forgot to free before returning

**Pattern 4: Nested structure leak**
```
800 bytes in 1 blocks are definitely lost
2400 bytes in 3 blocks are indirectly lost
    at malloc (program.c:40)
    at create_tree (program.c:45)
```
→ Parent structure leaked, children also lost

#### The 5-Second Leak Detection Method

**Quick workflow for development:**

1. **Write code** with malloc/free
2. **Run**: `valgrind --leak-check=full ./program 2>&1 | tail -20`
3. **Look for**: "All heap blocks were freed" or "definitely lost"
4. **If leak found**: Check the line numbers in backtrace
5. **Fix**: Add free() in all code paths
6. **Verify**: Run valgrind again

**Pro tip**: Add to your build script:
```bash
#!/bin/bash
gcc -g -O0 program.c -o program && \
valgrind --leak-check=full --error-exitcode=1 ./program
# Exit code 1 if leaks found - fails automated tests!
```

## Preventing Memory Leaks

### Strategy 1: RAII Pattern (Resource Acquisition Is Initialization)

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;
    size_t size;
} Array;

// Constructor - acquires resource
Array *array_create(size_t size) {
    Array *arr = malloc(sizeof(Array));
    if (arr == NULL) {
        return NULL;
    }

    arr->data = malloc(size * sizeof(int));
    if (arr->data == NULL) {
        free(arr);
        return NULL;
    }

    arr->size = size;
    return arr;
}

// Destructor - releases resource
void array_destroy(Array *arr) {
    if (arr != NULL) {
        free(arr->data);
        free(arr);
    }
}

int main() {
    Array *arr = array_create(10);
    if (arr == NULL) {
        return 1;
    }

    // Use array...
    for (size_t i = 0; i < arr->size; i++) {
        arr->data[i] = i;
    }

    // Single cleanup call
    array_destroy(arr);

    return 0;
}
```

### Strategy 2: Cleanup Labels with goto

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int process_data(const char *input) {
    char *buffer = NULL;
    int *numbers = NULL;
    char *result = NULL;
    int status = -1;

    buffer = malloc(1024);
    if (buffer == NULL) {
        goto cleanup;
    }

    numbers = malloc(100 * sizeof(int));
    if (numbers == NULL) {
        goto cleanup;
    }

    result = malloc(2048);
    if (result == NULL) {
        goto cleanup;
    }

    // Process data...
    strcpy(buffer, input);
    for (int i = 0; i < 100; i++) {
        numbers[i] = i;
    }

    status = 0;  // Success

cleanup:
    // Free all allocations - free(NULL) is safe
    free(buffer);
    free(numbers);
    free(result);

    return status;
}

int main() {
    int result = process_data("test data");
    printf("Result: %d\n", result);
    return 0;
}
```

### Strategy 3: Smart Pointer Pattern

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    void *ptr;
    void (*destructor)(void*);
} SmartPtr;

SmartPtr smart_ptr_create(void *ptr, void (*destructor)(void*)) {
    SmartPtr sp;
    sp.ptr = ptr;
    sp.destructor = destructor;
    return sp;
}

void smart_ptr_destroy(SmartPtr *sp) {
    if (sp != NULL && sp->ptr != NULL) {
        if (sp->destructor != NULL) {
            sp->destructor(sp->ptr);
        } else {
            free(sp->ptr);
        }
        sp->ptr = NULL;
    }
}

// Custom destructor for complex types
void free_int_array(void *ptr) {
    free(ptr);
    printf("Custom destructor called\n");
}

int main() {
    int *data = malloc(10 * sizeof(int));
    if (data == NULL) {
        return 1;
    }

    SmartPtr sp = smart_ptr_create(data, free_int_array);

    // Use data through sp.ptr
    int *arr = (int*)sp.ptr;
    for (int i = 0; i < 10; i++) {
        arr[i] = i;
    }

    // Automatic cleanup
    smart_ptr_destroy(&sp);

    return 0;
}
```

## Real-World Leak Example and Fix

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char *data;
    struct Node *next;
} Node;

// LEAKY VERSION
Node *list_append_leaky(Node *head, const char *data) {
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL) {
        return head;
    }

    new_node->data = malloc(strlen(data) + 1);
    if (new_node->data == NULL) {
        // LEAK! Forgot to free new_node
        return head;
    }

    strcpy(new_node->data, data);
    new_node->next = NULL;

    if (head == NULL) {
        return new_node;
    }

    Node *current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = new_node;

    return head;
}

// FIXED VERSION
Node *list_append_fixed(Node *head, const char *data) {
    Node *new_node = malloc(sizeof(Node));
    if (new_node == NULL) {
        return head;
    }

    new_node->data = malloc(strlen(data) + 1);
    if (new_node->data == NULL) {
        free(new_node);  // Fix: free node on error
        return head;
    }

    strcpy(new_node->data, data);
    new_node->next = NULL;

    if (head == NULL) {
        return new_node;
    }

    Node *current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = new_node;

    return head;
}

void list_free(Node *head) {
    Node *current = head;
    while (current != NULL) {
        Node *next = current->next;
        free(current->data);
        free(current);
        current = next;
    }
}

int main() {
    Node *list = NULL;

    list = list_append_fixed(list, "First");
    list = list_append_fixed(list, "Second");
    list = list_append_fixed(list, "Third");

    // Print list
    Node *current = list;
    while (current != NULL) {
        printf("%s\n", current->data);
        current = current->next;
    }

    // Cleanup
    list_free(list);

    return 0;
}
```

## Why This Matters

Memory leaks might seem harmless in small test programs, but they're serious bugs in production:

**1. Long-Running Programs**
Servers, daemons, embedded systems run for days/months/years:
```c
// Web server processes 1000 requests/sec
// Leaks 1KB per request
// = 1GB leaked per 1000 seconds (~17 minutes)
// = System runs out of memory and crashes
```

**2. Resource Exhaustion**
Operating systems limit memory per process:
- Mobile devices: Severe memory constraints
- Embedded systems: Fixed RAM (no swap)
- Cloud: Memory costs money (per-GB pricing)
- Containers: Memory limits enforced

**3. Real-World Consequences**

**Examples of leak disasters:**
- **Mars Rover** (1997): Memory leak in path planning caused reboots
- **Heartbleed** (2014): Not a traditional leak, but memory-related bug exposed private data
- **PlayStation Network** (2011): Server memory leaks contributed to downtime
- **Apache server**: Small leak caused crashes after days of uptime

**Performance degradation:**
- Leaks cause paging/swapping (disk access = slow)
- Garbage collection in mixed languages (C libraries called from Python/Java)
- Memory fragmentation makes allocations slower
- System OOM killer terminates your process

**4. Leak Patterns in Real Software**

**Web servers:**
```c
void handle_request(Request *req) {
    char *response = malloc(BUFFER_SIZE);
    if (!response) return;  // Leak on error!

    process(req, response);
    send_response(response);
    // Forgot free(response) - leaks on every request!
}
```

**Database connections:**
```c
void query_db(const char *sql) {
    Connection *conn = connect_to_db();
    if (!conn) return;

    Result *res = execute(conn, sql);
    if (!res) return;  // Leaked conn!

    process_results(res);
    free(res);
    // Forgot disconnect(conn) - connection leak!
}
```

**5. Testing and Maintenance**

**Development phase:**
- Small leaks accumulate during testing
- Valgrind catches them before deployment
- CI/CD integration prevents merging leaky code

**Production phase:**
- Memory monitoring alerts on growth
- Profiling tools identify hot spots
- Gradual memory growth → investigate leaks

**6. The Cost of Leaks**

**Direct costs:**
- Cloud hosting: Pay for wasted memory
- Hardware: Need more RAM than necessary
- Downtime: Restarts to clear leaked memory

**Indirect costs:**
- Developer time debugging production issues
- Customer trust lost from outages
- Technical debt from "workaround" restarts

**Real numbers:**
- 1MB leak × 1000 concurrent users = 1GB wasted
- Restart server daily vs fix leak = ongoing maintenance burden
- One critical leak can take days to debug in production

**7. Professional Practices**

**Prevention:**
- **Code review**: Check all malloc/free pairs
- **Static analysis**: Tools like Coverity, clang-analyzer
- **Runtime checks**: Valgrind, AddressSanitizer
- **Automated testing**: Run valgrind in CI pipeline
- **Ownership patterns**: Document who frees what

**Detection:**
- **Development**: Valgrind on every build
- **Testing**: Memory profilers (massif, heaptrack)
- **Production**: Monitoring memory usage trends
- **Post-mortem**: Heap dumps, memory profilers

**Mitigation when you can't fix:**
- Restart service periodically (temporary)
- Memory limits to prevent system-wide impact
- Resource pooling to limit allocations
- Migration to languages with GC (long-term)

## Key Takeaways

1. **Memory leaks waste resources** and can crash long-running programs
2. **Every allocation needs a corresponding free** in all code paths
3. **Don't lose pointers** before freeing the memory they point to
4. **Use cleanup patterns** (goto cleanup, RAII, smart pointers)
5. **Test with Valgrind** to catch leaks during development
6. **Track allocations** in complex programs
7. **Free in reverse order** for nested structures
8. **Small leaks accumulate** - even 1 byte leaked millions of times is serious

## Exercises

1. Write a program that demonstrates each common leak pattern
2. Create a memory tracking system that reports leaks at program exit
3. Fix a deliberately leaky linked list implementation
4. Implement a memory pool that prevents leaks by tracking all allocations
5. Write a program that leaks memory in a loop and observe memory usage grow
6. Create wrapper functions for malloc/free that help prevent leaks

In the next step, we'll explore dangling pointers and use-after-free errors, another critical memory safety issue.
