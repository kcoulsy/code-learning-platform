---
title: "Arrays Basics"
description: "Learn to work with collections using arrays in C"
order: 4
---

# Arrays Basics

Arrays are fundamental data structures that allow you to store multiple values of the same type in contiguous memory locations. They're essential for working with collections of data efficiently.

## Introduction

An array is a fixed-size collection of elements of the same type. Instead of declaring separate variables for related data (like `score1`, `score2`, `score3`), you can declare a single array that holds all values.

Arrays in C:
- Have a fixed size determined at declaration
- Store elements in contiguous memory
- Use zero-based indexing (first element is at index 0)
- Provide fast access to elements via index
- Do not track their own size (you must remember it!)

## Declaration and Initialization

Basic syntax: `type arrayName[size];`

## Code Examples

### Example 1: Array Declaration and Initialization

```c
#include <stdio.h>

int main() {
    // Declaration with size
    int numbers[5];  // Array of 5 integers (uninitialized)

    // Declaration with initialization
    int scores[5] = {85, 92, 78, 95, 88};

    // Partial initialization (rest are 0)
    int values[5] = {1, 2};  // {1, 2, 0, 0, 0}

    // Size inferred from initializer
    int ages[] = {25, 30, 35, 40};  // Size is 4

    // Initialize all to zero
    int zeros[10] = {0};  // All elements are 0

    // Print the scores
    printf("Scores:\n");
    for (int i = 0; i < 5; i++) {
        printf("Score %d: %d\n", i + 1, scores[i]);
    }

    return 0;
}
```

**Output:**
```
Scores:
Score 1: 85
Score 2: 92
Score 3: 78
Score 4: 95
Score 5: 88
```

### Example 2: Accessing and Modifying Array Elements

```c
#include <stdio.h>

int main() {
    int temperatures[7];  // Week's temperatures

    // Assign values using index
    temperatures[0] = 72;  // Monday
    temperatures[1] = 75;
    temperatures[2] = 68;
    temperatures[3] = 70;
    temperatures[4] = 73;
    temperatures[5] = 76;
    temperatures[6] = 74;  // Sunday

    // Access and print
    printf("Temperature on Wednesday: %d\n", temperatures[2]);

    // Modify an element
    temperatures[2] = 80;
    printf("Updated Wednesday temperature: %d\n", temperatures[2]);

    // Print all temperatures
    printf("\nWeek's temperatures:\n");
    char* days[] = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};
    for (int i = 0; i < 7; i++) {
        printf("%s: %d°F\n", days[i], temperatures[i]);
    }

    return 0;
}
```

**Output:**
```
Temperature on Wednesday: 68
Updated Wednesday temperature: 80

Week's temperatures:
Mon: 72°F
Tue: 75°F
Wed: 80°F
Thu: 70°F
Fri: 73°F
Sat: 76°F
Sun: 74°F
```

### Example 3: Computing Array Statistics

```c
#include <stdio.h>

int main() {
    int scores[] = {85, 92, 78, 95, 88, 76, 91, 84};
    int size = sizeof(scores) / sizeof(scores[0]);  // Calculate array size

    // Calculate sum and average
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += scores[i];
    }
    double average = (double)sum / size;

    // Find minimum and maximum
    int min = scores[0];
    int max = scores[0];
    for (int i = 1; i < size; i++) {
        if (scores[i] < min) {
            min = scores[i];
        }
        if (scores[i] > max) {
            max = scores[i];
        }
    }

    // Print results
    printf("Number of scores: %d\n", size);
    printf("Sum: %d\n", sum);
    printf("Average: %.2f\n", average);
    printf("Minimum: %d\n", min);
    printf("Maximum: %d\n", max);

    return 0;
}
```

**Output:**
```
Number of scores: 8
Sum: 689
Average: 86.12
Minimum: 76
Maximum: 95
```

**Important technique**: `sizeof(array) / sizeof(array[0])` calculates the number of elements.

### Example 4: Arrays as Function Parameters

```c
#include <stdio.h>

// Arrays are passed by reference (pointer to first element)
void printArray(int arr[], int size) {
    printf("Array elements: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Function that modifies array
void doubleValues(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

// Calculate sum
int sumArray(int arr[], int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum;
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = 5;

    printf("Original array:\n");
    printArray(numbers, size);

    printf("Sum: %d\n", sumArray(numbers, size));

    doubleValues(numbers, size);
    printf("\nAfter doubling:\n");
    printArray(numbers, size);
    printf("Sum: %d\n", sumArray(numbers, size));

    return 0;
}
```

**Output:**
```
Original array:
Array elements: 1 2 3 4 5
Sum: 15

After doubling:
Array elements: 2 4 6 8 10
Sum: 30
```

**Critical point**: Arrays are passed by reference, so modifications inside functions affect the original array!

### Example 5: Searching and Sorting

```c
#include <stdio.h>

// Linear search
int findValue(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;  // Return index where found
        }
    }
    return -1;  // Not found
}

// Bubble sort (simple sorting algorithm)
void bubbleSort(int arr[], int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int numbers[] = {64, 34, 25, 12, 22, 11, 90};
    int size = 7;

    printf("Original array: ");
    printArray(numbers, size);

    // Search for value
    int target = 25;
    int index = findValue(numbers, size, target);
    if (index != -1) {
        printf("Found %d at index %d\n", target, index);
    } else {
        printf("%d not found\n", target);
    }

    // Sort array
    bubbleSort(numbers, size);
    printf("\nSorted array: ");
    printArray(numbers, size);

    return 0;
}
```

**Output:**
```
Original array: 64 34 25 12 22 11 90
Found 25 at index 2

Sorted array: 11 12 22 25 34 64 90
```

## Common Pitfalls

### Pitfall 1: Array Index Out of Bounds

```c
int numbers[5] = {1, 2, 3, 4, 5};

// WRONG: Accessing beyond array bounds
printf("%d\n", numbers[5]);   // Index 5 doesn't exist! (valid: 0-4)
printf("%d\n", numbers[10]);  // Way out of bounds!
numbers[-1] = 10;             // Negative index!

// CORRECT: Stay within bounds
for (int i = 0; i < 5; i++) {  // i goes from 0 to 4
    printf("%d\n", numbers[i]);
}
```

**Problem**: C doesn't check array bounds! Accessing out-of-bounds memory causes undefined behavior (crashes, corruption, security vulnerabilities).

### Pitfall 2: Forgetting Array Size

```c
void printArray(int arr[]) {  // Size information lost!
    // How many elements? Can't use sizeof here!
    int size = sizeof(arr) / sizeof(arr[0]);  // WRONG: gives pointer size!
}

// CORRECT: Always pass size as parameter
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}
```

### Pitfall 3: Uninitialized Arrays

```c
int numbers[5];  // Contains garbage values!

printf("%d\n", numbers[0]);  // Undefined - could be anything!

// CORRECT: Initialize
int numbers[5] = {0};  // All zeros
// or
for (int i = 0; i < 5; i++) {
    numbers[i] = 0;
}
```

### Pitfall 4: Assignment After Declaration

```c
int numbers[3];
numbers = {1, 2, 3};  // ERROR: Can't assign to array!

// CORRECT: Initialize at declaration or assign element by element
int numbers[3] = {1, 2, 3};  // OK
// or
int numbers[3];
numbers[0] = 1;
numbers[1] = 2;
numbers[2] = 3;
```

## Exercises

### Exercise 1: Reverse Array
Write a function that reverses an array in place (modifies the original array).
Example: `{1, 2, 3, 4, 5}` becomes `{5, 4, 3, 2, 1}`

### Exercise 2: Find Second Largest
Write a function that finds the second largest element in an array. Handle edge cases (array with all same values, array with less than 2 elements).

### Exercise 3: Array Rotation
Write a function that rotates an array to the right by k positions.
Example: `rotate({1, 2, 3, 4, 5}, 5, 2)` results in `{4, 5, 1, 2, 3}`

### Exercise 4: Remove Duplicates
Write a function that removes duplicate values from a sorted array and returns the new size.
Example: `{1, 1, 2, 2, 3, 4, 4}` becomes `{1, 2, 3, 4}` with size 4

### Exercise 5: Merge Sorted Arrays
Write a function that merges two sorted arrays into a third sorted array.

## Key Takeaways

1. **Arrays**: Fixed-size collections of same-type elements
2. **Zero-Based Indexing**: First element at index 0, last at index n-1
3. **Declaration**: `type name[size]` or `type name[] = {...}`
4. **Size Calculation**: `sizeof(array) / sizeof(array[0])` works only in same scope
5. **Bounds**: C doesn't check bounds - you must ensure valid indices!
6. **Pass by Reference**: Arrays passed to functions can be modified
7. **Size Parameter**: Always pass array size to functions
8. **Initialization**: Uninitialized arrays contain garbage; use `{0}` for all zeros
9. **Contiguous Memory**: Elements stored consecutively for fast access
10. **Common Operations**: Search, sort, reverse, sum, min/max

Arrays are the foundation for more complex data structures. Master them, and you'll be ready for multidimensional arrays, strings, and dynamic memory allocation!
