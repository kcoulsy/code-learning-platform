---
id: project-setup
title: 'Project Setup'
order: 1
---

# Project Setup

## Prerequisites

- Completion of Lesson 1: Data Structures
- Solid understanding of C programming
- Comfortable with Makefiles and build systems

## Learning Objectives

By the end of this step, you will:

- Set up a professional C project structure
- Create a Makefile for building your database
- Define core data types for your key-value store
- Implement proper memory management patterns
- Establish coding conventions for the project

## Project Overview

We're building a **production-quality in-memory key-value store** that will serve as the foundation for our database. This is not a toy project—we're writing code that could be used in real systems.

### Project Structure

```
database/
├── Makefile
├── src/
│   ├── main.c
│   ├── kv_store.h
│   ├── kv_store.c
│   ├── hash_table.h
│   ├── hash_table.c
│   └── utils.h
├── tests/
│   └── test_hash_table.c
└── docs/
    └── README.md
```

## Complete Implementation

### 1. Makefile

```makefile
# Makefile for Database Project

# Compiler settings
CC = gcc
CFLAGS = -Wall -Wextra -Werror -std=c11 -O2
CFLAGS_DEBUG = -Wall -Wextra -std=c11 -g -O0 -DDEBUG
LDFLAGS =

# Directories
SRC_DIR = src
TEST_DIR = tests
BUILD_DIR = build
BIN_DIR = bin

# Source files
SOURCES = $(wildcard $(SRC_DIR)/*.c)
OBJECTS = $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(SOURCES))

# Test files
TEST_SOURCES = $(wildcard $(TEST_DIR)/*.c)
TEST_OBJECTS = $(patsubst $(TEST_DIR)/%.c,$(BUILD_DIR)/test_%.o,$(TEST_SOURCES))

# Targets
TARGET = $(BIN_DIR)/database
TEST_TARGET = $(BIN_DIR)/test_runner

# Default target
all: directories $(TARGET)

# Create necessary directories
directories:
	@mkdir -p $(BUILD_DIR)
	@mkdir -p $(BIN_DIR)

# Build the main executable
$(TARGET): $(OBJECTS)
	$(CC) $(OBJECTS) -o $@ $(LDFLAGS)
	@echo "Built: $@"

# Compile source files
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# Build and run tests
test: directories $(TEST_TARGET)
	./$(TEST_TARGET)

$(TEST_TARGET): $(filter-out $(BUILD_DIR)/main.o,$(OBJECTS)) $(TEST_OBJECTS)
	$(CC) $^ -o $@ $(LDFLAGS)

$(BUILD_DIR)/test_%.o: $(TEST_DIR)/%.c
	$(CC) $(CFLAGS) -c $< -o $@

# Debug build
debug: CFLAGS = $(CFLAGS_DEBUG)
debug: clean all

# Clean build artifacts
clean:
	@rm -rf $(BUILD_DIR) $(BIN_DIR)
	@echo "Cleaned build artifacts"

# Run the database
run: all
	./$(TARGET)

# Format code (requires clang-format)
format:
	@find $(SRC_DIR) $(TEST_DIR) -name "*.c" -o -name "*.h" | xargs clang-format -i
	@echo "Code formatted"

# Static analysis (requires cppcheck)
analyze:
	@cppcheck --enable=all --suppress=missingIncludeSystem $(SRC_DIR)

# Memory leak check (requires valgrind)
leakcheck: debug
	@valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./$(TARGET)

# Help
help:
	@echo "Available targets:"
	@echo "  make          - Build the database"
	@echo "  make test     - Build and run tests"
	@echo "  make debug    - Build with debug symbols"
	@echo "  make clean    - Remove build artifacts"
	@echo "  make run      - Build and run the database"
	@echo "  make format   - Format code with clang-format"
	@echo "  make analyze  - Run static analysis"
	@echo "  make leakcheck- Check for memory leaks"

.PHONY: all directories test debug clean run format analyze leakcheck help
```

### 2. Core Data Types (src/utils.h)

```c
#ifndef UTILS_H
#define UTILS_H

#include <stddef.h>
#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// VERSION AND METADATA
// ============================================================================

#define DB_VERSION_MAJOR 1
#define DB_VERSION_MINOR 0
#define DB_VERSION_PATCH 0

#define DB_NAME "SimpleKV"
#define DB_VERSION_STRING "1.0.0"

// ============================================================================
// ERROR HANDLING
// ============================================================================

typedef enum {
    DB_OK = 0,
    DB_ERROR_NOMEM = -1,        // Out of memory
    DB_ERROR_NOTFOUND = -2,     // Key not found
    DB_ERROR_EXISTS = -3,       // Key already exists
    DB_ERROR_INVALID = -4,      // Invalid argument
    DB_ERROR_IO = -5,           // I/O error
    DB_ERROR_CORRUPT = -6,      // Data corruption
    DB_ERROR_FULL = -7,         // Storage full
    DB_ERROR_BUSY = -8,         // Resource busy
    DB_ERROR_UNKNOWN = -99      // Unknown error
} db_error_t;

// Get error string
const char *db_strerror(db_error_t error);

// ============================================================================
// LOGGING
// ============================================================================

typedef enum {
    LOG_LEVEL_DEBUG = 0,
    LOG_LEVEL_INFO = 1,
    LOG_LEVEL_WARN = 2,
    LOG_LEVEL_ERROR = 3,
    LOG_LEVEL_FATAL = 4
} log_level_t;

// Set minimum log level
void db_set_log_level(log_level_t level);

// Logging macros
#define db_debug(...) db_log(LOG_LEVEL_DEBUG, __FILE__, __LINE__, __VA_ARGS__)
#define db_info(...)  db_log(LOG_LEVEL_INFO, __FILE__, __LINE__, __VA_ARGS__)
#define db_warn(...)  db_log(LOG_LEVEL_WARN, __FILE__, __LINE__, __VA_ARGS__)
#define db_error(...) db_log(LOG_LEVEL_ERROR, __FILE__, __LINE__, __VA_ARGS__)
#define db_fatal(...) db_log(LOG_LEVEL_FATAL, __FILE__, __LINE__, __VA_ARGS__)

void db_log(log_level_t level, const char *file, int line, const char *fmt, ...);

// ============================================================================
// MEMORY MANAGEMENT
// ============================================================================

// Safe malloc that logs on failure
void *db_malloc(size_t size, const char *file, int line);
void *db_calloc(size_t nmemb, size_t size, const char *file, int line);
void *db_realloc(void *ptr, size_t size, const char *file, int line);
char *db_strdup(const char *s, const char *file, int line);

// Macros to capture file/line information
#define DB_MALLOC(size) db_malloc(size, __FILE__, __LINE__)
#define DB_CALLOC(n, size) db_calloc(n, size, __FILE__, __LINE__)
#define DB_REALLOC(ptr, size) db_realloc(ptr, size, __FILE__, __LINE__)
#define DB_STRDUP(s) db_strdup(s, __FILE__, __LINE__)
#define DB_FREE(ptr) do { free(ptr); (ptr) = NULL; } while(0)

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Get current timestamp in milliseconds
uint64_t db_get_time_ms(void);

// Format bytes for human reading (e.g., "1.5 MB")
void db_format_bytes(uint64_t bytes, char *buf, size_t buf_size);

// Simple string hash (FNV-1a)
uint64_t db_hash_string(const char *str);

// Check if string is valid identifier (alphanumeric + underscore)
bool db_is_valid_identifier(const char *str);

// Trim whitespace from string (modifies in place)
char *db_trim(char *str);

#ifdef __cplusplus
}
#endif

#endif // UTILS_H
```

### 3. Utils Implementation (src/utils.c)

```c
#include "utils.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <errno.h>

// Current log level
static log_level_t g_log_level = LOG_LEVEL_INFO;

// Log level names
static const char *log_level_names[] = {
    "DEBUG", "INFO", "WARN", "ERROR", "FATAL"
};

const char *db_strerror(db_error_t error) {
    switch (error) {
        case DB_OK:           return "Success";
        case DB_ERROR_NOMEM:  return "Out of memory";
        case DB_ERROR_NOTFOUND: return "Key not found";
        case DB_ERROR_EXISTS: return "Key already exists";
        case DB_ERROR_INVALID: return "Invalid argument";
        case DB_ERROR_IO:     return "I/O error";
        case DB_ERROR_CORRUPT: return "Data corruption";
        case DB_ERROR_FULL:   return "Storage full";
        case DB_ERROR_BUSY:   return "Resource busy";
        case DB_ERROR_UNKNOWN: return "Unknown error";
        default:              return "Invalid error code";
    }
}

void db_set_log_level(log_level_t level) {
    g_log_level = level;
}

void db_log(log_level_t level, const char *file, int line, const char *fmt, ...) {
    if (level < g_log_level) {
        return;
    }

    // Get current time
    time_t now;
    time(&now);
    struct tm *tm_info = localtime(&now);
    char time_buf[20];
    strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", tm_info);

    // Print log header
    fprintf(stderr, "[%s] %-5s %s:%d: ",
            time_buf, log_level_names[level], file, line);

    // Print message
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);

    fprintf(stderr, "\n");

    // Fatal errors exit the program
    if (level == LOG_LEVEL_FATAL) {
        exit(EXIT_FAILURE);
    }
}

void *db_malloc(size_t size, const char *file, int line) {
    void *ptr = malloc(size);
    if (!ptr && size > 0) {
        db_log(LOG_LEVEL_ERROR, file, line,
               "Failed to allocate %zu bytes: %s", size, strerror(errno));
    }
    return ptr;
}

void *db_calloc(size_t nmemb, size_t size, const char *file, int line) {
    void *ptr = calloc(nmemb, size);
    if (!ptr && nmemb > 0 && size > 0) {
        db_log(LOG_LEVEL_ERROR, file, line,
               "Failed to allocate %zu x %zu bytes: %s",
               nmemb, size, strerror(errno));
    }
    return ptr;
}

void *db_realloc(void *ptr, size_t size, const char *file, int line) {
    void *new_ptr = realloc(ptr, size);
    if (!new_ptr && size > 0) {
        db_log(LOG_LEVEL_ERROR, file, line,
               "Failed to reallocate to %zu bytes: %s", size, strerror(errno));
    }
    return new_ptr;
}

char *db_strdup(const char *s, const char *file, int line) {
    if (!s) return NULL;

    size_t len = strlen(s);
    char *copy = db_malloc(len + 1, file, line);
    if (copy) {
        memcpy(copy, s, len + 1);
    }
    return copy;
}

uint64_t db_get_time_ms(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
}

void db_format_bytes(uint64_t bytes, char *buf, size_t buf_size) {
    const char *units[] = {"B", "KB", "MB", "GB", "TB"};
    int unit_idx = 0;
    double size = (double)bytes;

    while (size >= 1024.0 && unit_idx < 4) {
        size /= 1024.0;
        unit_idx++;
    }

    snprintf(buf, buf_size, "%.2f %s", size, units[unit_idx]);
}

uint64_t db_hash_string(const char *str) {
    uint64_t hash = 14695981039346656037ULL;
    while (*str) {
        hash ^= (unsigned char)*str++;
        hash *= 1099511628211ULL;
    }
    return hash;
}

bool db_is_valid_identifier(const char *str) {
    if (!str || !*str) return false;

    // First character must be letter or underscore
    if (!isalpha((unsigned char)*str) && *str != '_') {
        return false;
    }

    // Rest can be alphanumeric or underscore
    while (*++str) {
        if (!isalnum((unsigned char)*str) && *str != '_') {
            return false;
        }
    }

    return true;
}

char *db_trim(char *str) {
    if (!str) return NULL;

    // Trim leading whitespace
    while (isspace((unsigned char)*str)) str++;

    if (*str == '\0') return str;

    // Trim trailing whitespace
    char *end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) end--;

    end[1] = '\0';
    return str;
}
```

### 4. Value Types (src/kv_store.h)

```c
#ifndef KV_STORE_H
#define KV_STORE_H

#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// VALUE TYPES
// ============================================================================

typedef enum {
    VALUE_TYPE_NULL = 0,
    VALUE_TYPE_INT = 1,
    VALUE_TYPE_FLOAT = 2,
    VALUE_TYPE_STRING = 3,
    VALUE_TYPE_BLOB = 4,
    VALUE_TYPE_BOOL = 5
} value_type_t;

// Forward declaration
typedef struct kv_store kv_store_t;

// Value structure (variant type)
typedef struct {
    value_type_t type;
    union {
        int64_t int_val;
        double float_val;
        char *string_val;
        struct {
            void *data;
            size_t size;
        } blob_val;
        bool bool_val;
    } data;
} value_t;

// ============================================================================
// VALUE OPERATIONS
// ============================================================================

// Create values
value_t value_from_int(int64_t val);
value_t value_from_float(double val);
value_t value_from_string(const char *val);
value_t value_from_blob(const void *data, size_t size);
value_t value_from_bool(bool val);
value_t value_null(void);

// Copy a value (deep copy for strings/blobs)
db_error_t value_copy(const value_t *src, value_t *dst);

// Free value resources
void value_free(value_t *val);

// Compare two values
// Returns: -1 (a < b), 0 (a == b), 1 (a > b), -2 (incompatible types)
int value_compare(const value_t *a, const value_t *b);

// Convert value to string representation
// Returns number of characters written (excluding null terminator)
int value_to_string(const value_t *val, char *buf, size_t buf_size);

// Get size of value in bytes (for memory tracking)
size_t value_size(const value_t *val);

// ============================================================================
// KEY-VALUE STORE INTERFACE
// ============================================================================

// Create a new key-value store
kv_store_t *kv_store_create(void);

// Destroy a key-value store and free all memory
void kv_store_destroy(kv_store_t *store);

// Insert or update a key-value pair
// Makes a copy of both key and value
db_error_t kv_store_set(kv_store_t *store, const char *key, const value_t *value);

// Retrieve a value by key
// Returns pointer to internal value (do not modify!)
const value_t *kv_store_get(kv_store_t *store, const char *key);

// Delete a key-value pair
db_error_t kv_store_delete(kv_store_t *store, const char *key);

// Check if key exists
bool kv_store_exists(kv_store_t *store, const char *key);

// Get number of entries
size_t kv_store_count(kv_store_t *store);

// Clear all entries
db_error_t kv_store_clear(kv_store_t *store);

// ============================================================================
// ITERATION
// ============================================================================

typedef struct kv_iterator kv_iterator_t;

// Create an iterator
kv_iterator_t *kv_iterator_create(kv_store_t *store);

// Destroy an iterator
void kv_iterator_destroy(kv_iterator_t *iter);

// Move to next entry
// Returns true if there is a next entry, false at end
bool kv_iterator_next(kv_iterator_t *iter);

// Get current key (valid after successful next)
const char *kv_iterator_key(kv_iterator_t *iter);

// Get current value (valid after successful next)
const value_t *kv_iterator_value(kv_iterator_t *iter);

// Reset iterator to beginning
void kv_iterator_reset(kv_iterator_t *iter);

// ============================================================================
// STATISTICS AND INFO
// ============================================================================

typedef struct {
    size_t entry_count;         // Number of entries
    size_t total_key_bytes;     // Total bytes used by keys
    size_t total_value_bytes;   // Total bytes used by values
    size_t overhead_bytes;      // Metadata overhead
    size_t capacity;            // Current capacity
    double load_factor;         // Current load factor
} kv_stats_t;

// Get statistics
void kv_store_stats(kv_store_t *store, kv_stats_t *stats);

// Print statistics
void kv_store_print_stats(kv_store_t *store);

#ifdef __cplusplus
}
#endif

#endif // KV_STORE_H
```

### 5. Main Entry Point (src/main.c)

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "utils.h"
#include "kv_store.h"

static void print_usage(const char *program) {
    printf("Usage: %s [options]\n", program);
    printf("\nOptions:\n");
    printf("  -h, --help       Show this help message\n");
    printf("  -v, --version    Show version information\n");
    printf("  -d, --debug      Enable debug logging\n");
    printf("\n");
}

static void print_version(void) {
    printf("%s version %s\n", DB_NAME, DB_VERSION_STRING);
    printf("A simple key-value store database\n");
}

int main(int argc, char *argv[]) {
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            print_usage(argv[0]);
            return 0;
        }
        if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--version") == 0) {
            print_version();
            return 0;
        }
        if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--debug") == 0) {
            db_set_log_level(LOG_LEVEL_DEBUG);
            db_debug("Debug logging enabled");
        }
    }

    db_info("Starting %s %s", DB_NAME, DB_VERSION_STRING);

    // Create key-value store
    kv_store_t *store = kv_store_create();
    if (!store) {
        db_fatal("Failed to create key-value store");
    }

    db_info("Key-value store created successfully");

    // Test basic operations
    db_info("Testing basic operations...");

    // Insert some values
    value_t val1 = value_from_string("Hello, World!");
    kv_store_set(store, "greeting", &val1);
    value_free(&val1);

    value_t val2 = value_from_int(42);
    kv_store_set(store, "answer", &val2);
    value_free(&val2);

    value_t val3 = value_from_float(3.14159);
    kv_store_set(store, "pi", &val3);
    value_free(&val3);

    // Retrieve values
    const value_t *retrieved = kv_store_get(store, "greeting");
    if (retrieved) {
        char buf[256];
        value_to_string(retrieved, buf, sizeof(buf));
        db_info("Retrieved 'greeting': %s", buf);
    }

    // Print statistics
    kv_store_print_stats(store);

    // Cleanup
    kv_store_destroy(store);
    db_info("Database shutdown complete");

    return 0;
}
```

## Code Walkthrough

### Professional Project Structure

This isn't a single-file program—we're building a real system:

1. **Separation of concerns:** Utils, data types, and store are separate
2. **Error handling:** Comprehensive error codes and logging
3. **Memory safety:** Custom allocators that track file/line
4. **Build system:** Makefile with multiple targets
5. **Testing:** Separate test runner

### Value Type System

The `value_t` union supports multiple types:

- **NULL:** Missing or deleted values
- **INT:** 64-bit integers
- **FLOAT:** Double-precision floats
- **STRING:** Dynamic strings
- **BLOB:** Binary data
- **BOOL:** True/false

This flexibility allows our database to handle different data types.

### Memory Management

We use wrapper macros (`DB_MALLOC`, `DB_FREE`) that:

- Track allocation site (file/line)
- Log failures automatically
- Set pointers to NULL after free

This makes debugging memory issues much easier.

## Hands-On Exercise

### Challenge: Set Up Your Project

**Goal:** Create the complete project structure and verify it builds

**Requirements:**

1. **Create directory structure:**

   ```
   database/
   ├── Makefile
   ├── src/
   │   ├── main.c
   │   ├── utils.h
   │   ├── utils.c
   │   ├── kv_store.h
   │   └── kv_store.c
   └── tests/
       └── test_basic.c
   ```

2. **Create placeholder implementations:**
   - `kv_store.c` with stub functions that log "not implemented"
   - `test_basic.c` with a simple test that passes

3. **Verify build system:**
   - `make` should compile without errors
   - `make test` should run tests
   - `make clean` should remove build artifacts

4. **Test the executable:**
   - Run `./bin/database --version`
   - Run `./bin/database --help`
   - Run `./bin/database` and verify it starts

**Expected Output:**

```
$ make
Built: bin/database

$ ./bin/database --version
SimpleKV version 1.0.0
A simple key-value store database

$ ./bin/database
[2024-01-15 10:30:45] INFO  src/main.c:45: Starting SimpleKV 1.0.0
[2024-01-15 10:30:45] INFO  src/main.c:52: Key-value store created successfully
...
```

## Testing Your Code

```bash
# Create project directory
mkdir -p database/{src,tests,docs}
cd database

# Create all files above
# ... (copy the code) ...

# Build the project
make

# Run the database
./bin/database

# Run tests
make test

# Build with debug symbols
make debug

# Check for memory leaks
make leakcheck
```

## Solution

<details>
<summary>Click to see complete project setup</summary>

The complete code is provided above. Key points:

1. **Makefile** handles all build scenarios
2. **utils.h/c** provide foundation (logging, memory, errors)
3. **kv_store.h** defines the public interface
4. **main.c** is a minimal entry point

To complete the setup, create stub implementations:

```c
// src/kv_store.c - STUB VERSION
#include "kv_store.h"
#include "utils.h"

kv_store_t *kv_store_create(void) {
    db_info("kv_store_create: not fully implemented");
    return NULL;
}

void kv_store_destroy(kv_store_t *store) {
    (void)store;
    db_info("kv_store_destroy: not fully implemented");
}

db_error_t kv_store_set(kv_store_t *store, const char *key, const value_t *value) {
    (void)store; (void)key; (void)value;
    db_info("kv_store_set: not fully implemented");
    return DB_ERROR_UNKNOWN;
}

// ... implement other stubs similarly
```

This allows the project to compile while you implement features incrementally.

</details>

## Next Steps

In the next step, you'll implement the **hash table** that powers the key-value store. You'll:

- Implement the complete hash table from Lesson 1
- Add dynamic resizing and collision handling
- Integrate with the value type system
- Pass comprehensive unit tests

Get ready to write some serious code!
