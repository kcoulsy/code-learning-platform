---
id: b-tree-fundamentals
title: 'B-Tree Fundamentals'
order: 1
---

# B-Tree Fundamentals

## Prerequisites

- Completion of Lesson 3: Persistence
- Understanding of tree data structures
- Knowledge of balanced trees

## Learning Objectives

By the end of this step, you will:

- Understand B-tree properties and invariants
- Implement B-tree node structure
- Create insertion with splitting
- Build search operations
- Maintain B-tree balance

## Overview

B-trees are the foundation of database indexing. Unlike hash tables, they:

- Keep data sorted
- Support range queries
- Provide O(log n) operations
- Optimize disk I/O

## B-Tree Properties

For a B-tree of order m:

- Each node has at most 2m children
- Each node (except root) has at least m children
- Root has at least 2 children if not a leaf
- All leaves at same depth
- Keys in sorted order within nodes

## Implementation

### B-Tree Header (src/btree.h)

```c
#ifndef BTREE_H
#define BTREE_H

#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

// B-tree order (min degree)
// Each node has 2*BTREE_ORDER-1 keys and 2*BTREE_ORDER children max
#define BTREE_ORDER 4
#define BTREE_MAX_KEYS (2 * BTREE_ORDER - 1)
#define BTREE_MIN_KEYS (BTREE_ORDER - 1)
#define BTREE_MAX_CHILDREN (2 * BTREE_ORDER)

// Forward declarations
typedef struct btree_node btree_node_t;
typedef struct btree btree_t;

// Key comparison function
typedef int (*btree_compare_fn)(const void *a, const void *b);

// Key-value pair
typedef struct {
    void *key;
    void *value;
} btree_entry_t;

// B-tree node
struct btree_node {
    btree_entry_t entries[BTREE_MAX_KEYS];  // Keys and values
    btree_node_t *children[BTREE_MAX_CHILDREN];  // Child pointers
    int num_keys;                           // Number of keys in node
    bool is_leaf;                           // Is this a leaf node?
};

// B-tree structure
struct btree {
    btree_node_t *root;
    btree_compare_fn compare;
    size_t size;                            // Total entries
};

// ============================================================================
// LIFECYCLE
// ============================================================================

// Create a new B-tree with custom comparator
btree_t *btree_create(btree_compare_fn compare);

// Destroy B-tree and free all memory
void btree_destroy(btree_t *tree);

// Clear all entries
void btree_clear(btree_t *tree);

// ============================================================================
// OPERATIONS
// ============================================================================

// Insert key-value pair
// Returns DB_OK on success, DB_ERROR_EXISTS if key already present
db_error_t btree_insert(btree_t *tree, void *key, void *value);

// Insert or update (upsert)
db_error_t btree_upsert(btree_t *tree, void *key, void *value);

// Search for key
// Returns pointer to value, or NULL if not found
void *btree_search(btree_t *tree, const void *key);

// Delete key
// Returns DB_OK on success, DB_ERROR_NOTFOUND if key doesn't exist
db_error_t btree_delete(btree_t *tree, const void *key);

// Check if key exists
bool btree_contains(btree_t *tree, const void *key);

// Get number of entries
size_t btree_size(btree_t *tree);

// ============================================================================
// TREE PROPERTIES
// ============================================================================

// Get tree height
int btree_height(btree_t *tree);

// Check if tree is valid (for debugging)
bool btree_validate(btree_t *tree);

// Print tree structure (for debugging)
void btree_print(btree_t *tree);

#ifdef __cplusplus
}
#endif

#endif // BTREE_H
```

### B-Tree Implementation (src/btree.c)

```c
#include "btree.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ============================================================================
// NODE OPERATIONS
// ============================================================================

static btree_node_t *create_node(bool is_leaf) {
    btree_node_t *node = DB_MALLOC(sizeof(btree_node_t));
    if (!node) return NULL;

    memset(node, 0, sizeof(btree_node_t));
    node->is_leaf = is_leaf;
    node->num_keys = 0;

    return node;
}

static void destroy_node(btree_node_t *node) {
    if (!node) return;

    // Recursively destroy children
    if (!node->is_leaf) {
        for (int i = 0; i <= node->num_keys; i++) {
            destroy_node(node->children[i]);
        }
    }

    DB_FREE(node);
}

// ============================================================================
// SEARCH
// ============================================================================

static int find_key_index(btree_node_t *node, const void *key,
                          btree_compare_fn compare) {
    int idx = 0;
    while (idx < node->num_keys &\u0026
           compare(node->entries[idx].key, key) < 0) {
        idx++;
    }
    return idx;
}

static void *search_node(btree_node_t *node, const void *key,
                         btree_compare_fn compare) {
    int i = find_key_index(node, key, compare);

    // Check if found at position i
    if (i < node->num_keys &\u0026 compare(node->entries[i].key, key) == 0) {
        return node->entries[i].value;
    }

    // If leaf, not found
    if (node->is_leaf) {
        return NULL;
    }

    // Search appropriate child
    return search_node(node->children[i], key, compare);
}

void *btree_search(btree_t *tree, const void *key) {
    if (!tree || !tree->root || !key) {
        return NULL;
    }

    return search_node(tree->root, key, tree->compare);
}

bool btree_contains(btree_t *tree, const void *key) {
    return btree_search(tree, key) != NULL;
}

// ============================================================================
// INSERTION
// ============================================================================

static void split_child(btree_node_t *parent, int idx, btree_node_t *child) {
    // Create new node for the second half
    btree_node_t *new_node = create_node(child->is_leaf);

    // Move second half of keys to new node
    new_node->num_keys = BTREE_ORDER - 1;
    for (int i = 0; i < BTREE_ORDER - 1; i++) {
        new_node->entries[i] = child->entries[i + BTREE_ORDER];
    }

    // Move second half of children if not leaf
    if (!child->is_leaf) {
        for (int i = 0; i < BTREE_ORDER; i++) {
            new_node->children[i] = child->children[i + BTREE_ORDER];
        }
    }

    // Reduce child's key count
    child->num_keys = BTREE_ORDER - 1;

    // Make room in parent for new child
    for (int i = parent->num_keys; i >= idx + 1; i--) {
        parent->children[i + 1] = parent->children[i];
    }
    parent->children[idx + 1] = new_node;

    // Move middle key from child to parent
    for (int i = parent->num_keys - 1; i >= idx; i--) {
        parent->entries[i + 1] = parent->entries[i];
    }
    parent->entries[idx] = child->entries[BTREE_ORDER - 1];
    parent->num_keys++;
}

static void insert_non_full(btree_node_t *node, void *key, void *value,
                            btree_compare_fn compare) {
    int i = node->num_keys - 1;

    if (node->is_leaf) {
        // Insert into leaf
        // Find position and shift
        while (i >= 0 &\u0026 compare(node->entries[i].key, key) > 0) {
            node->entries[i + 1] = node->entries[i];
            i--;
        }

        node->entries[i + 1].key = key;
        node->entries[i + 1].value = value;
        node->num_keys++;
    } else {
        // Find child to insert into
        while (i >= 0 &\u0026 compare(node->entries[i].key, key) > 0) {
            i--;
        }
        i++;

        // Split child if full
        if (node->children[i]->num_keys == BTREE_MAX_KEYS) {
            split_child(node, i, node->children[i]);

            // Determine which child to go into
            if (compare(node->entries[i].key, key) < 0) {
                i++;
            }
        }

        insert_non_full(node->children[i], key, value, compare);
    }
}

db_error_t btree_insert(btree_t *tree, void *key, void *value) {
    if (!tree || !key) {
        return DB_ERROR_INVALID;
    }

    // Check if key already exists
    if (btree_contains(tree, key)) {
        return DB_ERROR_EXISTS;
    }

    // Create root if needed
    if (!tree->root) {
        tree->root = create_node(true);
        if (!tree->root) {
            return DB_ERROR_NOMEM;
        }
    }

    // Split root if full
    if (tree->root->num_keys == BTREE_MAX_KEYS) {
        btree_node_t *new_root = create_node(false);
        new_root->children[0] = tree->root;
        split_child(new_root, 0, tree->root);
        tree->root = new_root;
    }

    insert_non_full(tree->root, key, value, tree->compare);
    tree->size++;

    return DB_OK;
}

db_error_t btree_upsert(btree_t *tree, void *key, void *value) {
    // Check if key exists
    void *existing = btree_search(tree, key);
    if (existing) {
        // Update in place - would need to find and update
        // For simplicity, delete and re-insert
        btree_delete(tree, key);
    }
    return btree_insert(tree, key, value);
}

// ============================================================================
// LIFECYCLE
// ============================================================================

btree_t *btree_create(btree_compare_fn compare) {
    if (!compare) {
        return NULL;
    }

    btree_t *tree = DB_MALLOC(sizeof(btree_t));
    if (!tree) {
        return NULL;
    }

    tree->root = NULL;
    tree->compare = compare;
    tree->size = 0;

    return tree;
}

void btree_destroy(btree_t *tree) {
    if (!tree) return;

    destroy_node(tree->root);
    DB_FREE(tree);
}

void btree_clear(btree_t *tree) {
    if (!tree) return;

    destroy_node(tree->root);
    tree->root = NULL;
    tree->size = 0;
}

size_t btree_size(btree_t *tree) {
    return tree ? tree->size : 0;
}

// ============================================================================
// TREE PROPERTIES
// ============================================================================

static int node_height(btree_node_t *node) {
    if (!node) return 0;
    if (node->is_leaf) return 1;

    int max_child_height = 0;
    for (int i = 0; i <= node->num_keys; i++) {
        int h = node_height(node->children[i]);
        if (h > max_child_height) {
            max_child_height = h;
        }
    }

    return 1 + max_child_height;
}

int btree_height(btree_t *tree) {
    if (!tree || !tree->root) return 0;
    return node_height(tree->root);
}

// ============================================================================
// DELETION (simplified - returns not implemented)
// ============================================================================

db_error_t btree_delete(btree_t *tree, const void *key) {
    (void)tree;
    (void)key;
    // Full deletion with merging is complex
    // For now, mark as not implemented
    return DB_ERROR_UNKNOWN;
}

// ============================================================================
// DEBUGGING
// ============================================================================

static void print_node(btree_node_t *node, int depth) {
    if (!node) return;

    // Indent
    for (int i = 0; i < depth; i++) printf("  ");

    printf("[");
    for (int i = 0; i < node->num_keys; i++) {
        if (i > 0) printf(" ");
        printf("%p", node->entries[i].key);
    }
    printf("]");

    if (node->is_leaf) {
        printf(" (leaf)\n");
    } else {
        printf("\n");
        for (int i = 0; i <= node->num_keys; i++) {
            print_node(node->children[i], depth + 1);
        }
    }
}

void btree_print(btree_t *tree) {
    if (!tree || !tree->root) {
        printf("(empty)\n");
        return;
    }

    printf("B-Tree (size=%zu, height=%d):\n",
           tree->size, btree_height(tree));
    print_node(tree->root, 0);
}

bool btree_validate(btree_t *tree) {
    // Validation checks:
    // - All leaves at same depth
    // - Keys in sorted order
    // - Node key counts within bounds
    // (Implementation omitted for brevity)
    (void)tree;
    return true;
}
```

## Code Walkthrough

### Search Operation

1. Start at root
2. Find position where key should be
3. If found, return value
4. If leaf and not found, return NULL
5. Otherwise, recurse into appropriate child

### Insert Operation

1. If root is full, split it
2. Traverse to appropriate leaf
3. Insert key in sorted position
4. If node full, split and promote middle key

### Splitting

When a node has 2t-1 keys:

1. Create new node
2. Move t largest keys to new node
3. Promote middle key to parent
4. Update child pointers

## Hands-On Exercise

### Challenge: B-Tree Testing

**Goal:** Verify B-tree correctness

**Requirements:**

1. Insert 1000 random integers
2. Verify all can be found
3. Verify tree height is O(log n)
4. Verify keys are in sorted order (in-order traversal)
5. Test duplicate key rejection

**Expected Output:**

```
B-Tree Test
===========
Inserted: 1000 keys
Height: 3 (expected ~log_8(1000) â‰ˆ 3.3)
All keys found: YES
Sorted order: YES
Duplicate rejection: PASSED
```

## Next Steps

In the next step, you'll implement **B-tree iterators** for range queries and ordered traversal.
