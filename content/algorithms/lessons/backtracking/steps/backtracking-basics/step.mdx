---
id: backtracking-basics
title: Backtracking Basics
order: 1
---

# Backtracking Basics

Backtracking systematically searches through solution space, undoing choices when dead ends are reached.

## Template

```c
void backtrack(Solution *current, Problem *problem) {
    if (isComplete(current)) {
        addToSolutions(current);
        return;
    }

    for each candidate in candidates(current, problem) {
        if (isValid(candidate, current)) {
            makeChoice(current, candidate);
            backtrack(current, problem);
            undoChoice(current, candidate);
        }
    }
}
```

## N-Queens Problem

```c
#define N 8

int board[N][N];

void printBoard() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            printf("%c ", board[i][j] ? 'Q' : '.');
        }
        printf("\n");
    }
    printf("\n");
}

int isSafe(int row, int col) {
    // Check column
    for (int i = 0; i < row; i++) {
        if (board[i][col]) return 0;
    }

    // Check upper-left diagonal
    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
        if (board[i][j]) return 0;
    }

    // Check upper-right diagonal
    for (int i = row, j = col; i >= 0 && j < N; i--, j++) {
        if (board[i][j]) return 0;
    }

    return 1;
}

void solveNQueens(int row) {
    if (row == N) {
        printBoard();
        return;
    }

    for (int col = 0; col < N; col++) {
        if (isSafe(row, col)) {
            board[row][col] = 1;
            solveNQueens(row + 1);
            board[row][col] = 0;  // Backtrack
        }
    }
}
```

## Optimized N-Queens

```c
int cols[N];
int diag1[2 * N - 1];
int diag2[2 * N - 1];

void solveNQueensOptimized(int row, int *solutionCount) {
    if (row == N) {
        (*solutionCount)++;
        return;
    }

    for (int col = 0; col < N; col++) {
        int d1 = row + col;
        int d2 = row - col + N - 1;

        if (!cols[col] && !diag1[d1] && !diag2[d2]) {
            cols[col] = diag1[d1] = diag2[d2] = 1;
            solveNQueensOptimized(row + 1, solutionCount);
            cols[col] = diag1[d1] = diag2[d2] = 0;
        }
    }
}
```

## Sudoku Solver

```c
#define EMPTY 0

int isValid(int grid[][9], int row, int col, int num) {
    // Check row
    for (int x = 0; x < 9; x++) {
        if (grid[row][x] == num) return 0;
    }

    // Check column
    for (int x = 0; x < 9; x++) {
        if (grid[x][col] == num) return 0;
    }

    // Check 3x3 box
    int startRow = row - row % 3;
    int startCol = col - col % 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (grid[i + startRow][j + startCol] == num) return 0;
        }
    }

    return 1;
}

int findEmpty(int grid[][9], int *row, int *col) {
    for (*row = 0; *row < 9; (*row)++) {
        for (*col = 0; *col < 9; (*col)++) {
            if (grid[*row][*col] == EMPTY) return 1;
        }
    }
    return 0;
}

int solveSudoku(int grid[][9]) {
    int row, col;

    if (!findEmpty(grid, &row, &col)) {
        return 1;  // Solved
    }

    for (int num = 1; num <= 9; num++) {
        if (isValid(grid, row, col, num)) {
            grid[row][col] = num;
            if (solveSudoku(grid)) return 1;
            grid[row][col] = EMPTY;  // Backtrack
        }
    }
    return 0;  // No solution
}
```

## Subset Sum

```c
void subsetSum(int arr[], int n, int target) {
    int subset[n];
    subsetSumHelper(arr, 0, n, 0, target, subset, 0);
}

void subsetSumHelper(int arr[], int index, int n, int currentSum,
                     int target, int subset[], int subsetSize) {
    if (currentSum == target) {
        printSubset(subset, subsetSize);
        return;
    }
    if (currentSum > target || index == n) return;

    // Include current element
    subset[subsetSize] = arr[index];
    subsetSumHelper(arr, index + 1, n, currentSum + arr[index],
                    target, subset, subsetSize + 1);

    // Exclude current element
    subsetSumHelper(arr, index + 1, n, currentSum, target,
                    subset, subsetSize);
}
```

## Backtracking Tips

| Technique        | Description                          |
| ---------------- | ------------------------------------ |
| Early exit       | Return immediately if solution found |
| Pruning          | Skip branches that can't succeed     |
| Bit masks        | Use bitsets for speed (N-Queens)     |
| Forward checking | Check constraints immediately        |
| MRV heuristic    | Choose variable with fewest values   |
