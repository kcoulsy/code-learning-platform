---
title: "Memory Allocator Implementation"
order: 6
---

# Memory Allocator Implementation

## Introduction

With the design in place, it's time to implement your memory allocator! This step provides code scaffolding and implementation guidance, but leaves the core logic for you to complete.

We'll build incrementally: basic malloc/free first, then add coalescing, splitting, and advanced features.

## Project Setup

### Directory Structure

```bash
mkdir myallocator
cd myallocator
mkdir src include tests
touch Makefile README.md
```

### Makefile

```makefile
CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -Iinclude -g
LDFLAGS =

SRC_DIR = src
OBJ_DIR = obj
LIB_DIR = .
TEST_DIR = tests

# Library
LIB_SOURCES = $(SRC_DIR)/allocator.c
LIB_OBJECTS = $(LIB_SOURCES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
LIB_TARGET = $(LIB_DIR)/liballocator.a

# Tests
TEST_SOURCES = $(wildcard $(TEST_DIR)/*.c)
TEST_TARGETS = $(TEST_SOURCES:$(TEST_DIR)/%.c=$(TEST_DIR)/%)

.PHONY: all clean test

all: $(LIB_TARGET) $(TEST_TARGETS)

# Build library
$(LIB_TARGET): $(LIB_OBJECTS) | $(LIB_DIR)
	ar rcs $@ $^

# Build objects
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)
	$(CC) $(CFLAGS) -c $< -o $@

# Build tests
$(TEST_DIR)/%: $(TEST_DIR)/%.c $(LIB_TARGET)
	$(CC) $(CFLAGS) $< -L$(LIB_DIR) -lallocator -o $@

$(OBJ_DIR):
	mkdir -p $(OBJ_DIR)

$(LIB_DIR):
	mkdir -p $(LIB_DIR)

clean:
	rm -rf $(OBJ_DIR) $(LIB_TARGET) $(TEST_TARGETS)

test: $(TEST_TARGETS)
	@for test in $(TEST_TARGETS); do \
		echo "Running $$test..."; \
		$$test || exit 1; \
	done
	@echo "All tests passed!"
```

## Part 1: Basic Structure

### Header File: allocator.h

```c
#ifndef ALLOCATOR_H
#define ALLOCATOR_H

#include <stddef.h>
#include <stdint.h>

// Public API
void *my_malloc(size_t size);
void my_free(void *ptr);
void *my_realloc(void *ptr, size_t size);
void *my_calloc(size_t nmemb, size_t size);

// Debugging and stats
void allocator_init(void);
void allocator_print_stats(void);
void allocator_print_heap(void);
int allocator_check_integrity(void);

#endif // ALLOCATOR_H
```

### Internal Header: allocator_internal.h

```c
#ifndef ALLOCATOR_INTERNAL_H
#define ALLOCATOR_INTERNAL_H

#include "allocator.h"
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>

// Configuration
#define ALIGNMENT 8
#define ALIGN(size) (((size) + (ALIGNMENT - 1)) & ~(ALIGNMENT - 1))
#define MIN_BLOCK_SIZE (sizeof(block_header_t))

// Block header structure
typedef struct block_header {
    size_t size;                    // Size of data portion
    int is_free;                    // 1 if free, 0 if allocated
    struct block_header *next;      // Next block in free list
    struct block_header *prev;      // Previous block (for coalescing)
} block_header_t;

// Global state
extern block_header_t *free_list_head;
extern void *heap_start;
extern void *heap_end;

// Statistics
typedef struct {
    size_t total_allocated;
    size_t total_freed;
    size_t current_usage;
    size_t peak_usage;
    size_t num_blocks;
    size_t num_free_blocks;
} allocator_stats_t;

extern allocator_stats_t stats;

// Internal functions
block_header_t *find_free_block(size_t size);
void split_block(block_header_t *block, size_t size);
void coalesce_block(block_header_t *block);
block_header_t *expand_heap(size_t size);
void add_to_free_list(block_header_t *block);
void remove_from_free_list(block_header_t *block);

#endif // ALLOCATOR_INTERNAL_H
```

## Part 2: Global State

### allocator.c - Initialization

```c
#include "allocator_internal.h"

// Global variables
block_header_t *free_list_head = NULL;
void *heap_start = NULL;
void *heap_end = NULL;
allocator_stats_t stats = {0};

void allocator_init(void) {
    // Get initial program break
    heap_start = sbrk(0);
    heap_end = heap_start;

    // Reset statistics
    memset(&stats, 0, sizeof(stats));

    free_list_head = NULL;
}
```

## Part 3: Heap Expansion

### Requesting Memory from OS

```c
block_header_t *expand_heap(size_t size) {
    // Calculate total size needed (header + data)
    size_t total_size = sizeof(block_header_t) + size;

    // Request memory from OS
    void *request = sbrk(total_size);

    if (request == (void*)-1) {
        // sbrk failed
        return NULL;
    }

    // Initialize block header
    block_header_t *block = (block_header_t*)request;
    block->size = size;
    block->is_free = 0;  // Will be marked as allocated
    block->next = NULL;
    block->prev = NULL;

    // Update heap end
    heap_end = sbrk(0);

    // Update statistics
    stats.num_blocks++;

    return block;
}
```

**Key Points**:
- `sbrk(total_size)` moves program break up by `total_size` bytes
- Returns pointer to old break (start of new region)
- Returns `(void*)-1` on failure
- We initialize the header in the newly allocated space

## Part 4: Free List Management

### Adding to Free List

```c
void add_to_free_list(block_header_t *block) {
    block->is_free = 1;

    if (free_list_head == NULL) {
        // First free block
        free_list_head = block;
        block->next = NULL;
        block->prev = NULL;
    } else {
        // Insert at head (LIFO)
        block->next = free_list_head;
        block->prev = NULL;
        free_list_head->prev = block;
        free_list_head = block;
    }

    stats.num_free_blocks++;
}
```

**Alternative**: Insert in address order (helps coalescing)

```c
void add_to_free_list_sorted(block_header_t *block) {
    block->is_free = 1;

    // Find insertion point
    block_header_t *current = free_list_head;
    block_header_t *prev = NULL;

    while (current != NULL && current < block) {
        prev = current;
        current = current->next;
    }

    // Insert block
    block->next = current;
    block->prev = prev;

    if (prev != NULL) {
        prev->next = block;
    } else {
        free_list_head = block;
    }

    if (current != NULL) {
        current->prev = block;
    }

    stats.num_free_blocks++;
}
```

### Removing from Free List

```c
void remove_from_free_list(block_header_t *block) {
    if (block->prev != NULL) {
        block->prev->next = block->next;
    } else {
        // Block is head of list
        free_list_head = block->next;
    }

    if (block->next != NULL) {
        block->next->prev = block->prev;
    }

    block->next = NULL;
    block->prev = NULL;
    block->is_free = 0;

    stats.num_free_blocks--;
}
```

## Part 5: Finding Free Blocks

### First Fit Strategy

```c
block_header_t *find_free_block(size_t size) {
    block_header_t *current = free_list_head;

    // Search for first block large enough
    while (current != NULL) {
        if (current->is_free && current->size >= size) {
            return current;
        }
        current = current->next;
    }

    // No suitable block found
    return NULL;
}
```

### Best Fit Strategy (Optional)

```c
block_header_t *find_free_block_best_fit(size_t size) {
    block_header_t *current = free_list_head;
    block_header_t *best = NULL;
    size_t best_size = SIZE_MAX;

    // Search entire list for best fit
    while (current != NULL) {
        if (current->is_free && current->size >= size) {
            if (current->size < best_size) {
                best = current;
                best_size = current->size;

                // Exact match, stop searching
                if (best_size == size) {
                    break;
                }
            }
        }
        current = current->next;
    }

    return best;
}
```

## Part 6: Implementing malloc

### my_malloc()

```c
void *my_malloc(size_t size) {
    // Initialize on first call
    if (heap_start == NULL) {
        allocator_init();
    }

    // Handle edge cases
    if (size == 0) {
        return NULL;
    }

    // Align size
    size = ALIGN(size);

    // Search free list
    block_header_t *block = find_free_block(size);

    if (block != NULL) {
        // Found a free block
        remove_from_free_list(block);

        // Split if block is significantly larger
        if (block->size >= size + sizeof(block_header_t) + ALIGNMENT) {
            split_block(block, size);
        }

    } else {
        // No suitable block, request from OS
        block = expand_heap(size);

        if (block == NULL) {
            // Out of memory
            return NULL;
        }
    }

    // Mark as allocated
    block->is_free = 0;

    // Update statistics
    stats.total_allocated += block->size;
    stats.current_usage += block->size;
    if (stats.current_usage > stats.peak_usage) {
        stats.peak_usage = stats.current_usage;
    }

    // Return pointer to data (after header)
    return (void*)(block + 1);
}
```

**Important**: `block + 1` advances pointer by `sizeof(block_header_t)`, skipping the header.

## Part 7: Block Splitting

### split_block()

```c
void split_block(block_header_t *block, size_t size) {
    // Calculate where new block starts
    size_t old_size = block->size;
    block->size = size;

    // Create new block from remainder
    block_header_t *new_block =
        (block_header_t*)((char*)(block + 1) + size);

    new_block->size = old_size - size - sizeof(block_header_t);
    new_block->is_free = 1;
    new_block->next = NULL;
    new_block->prev = NULL;

    // Add remainder to free list
    add_to_free_list(new_block);

    // Update statistics
    stats.num_blocks++;
}
```

**Pointer Arithmetic**:
- `block + 1` → skip header (points to data)
- `(char*)(block + 1) + size` → skip data
- Cast to `block_header_t*` → new header location

**Visualization**:
```
Before split:
┌────────┬───────────────────────────────┐
│ Header │        128 bytes              │
└────────┴───────────────────────────────┘

After split_block(block, 32):
┌────────┬─────────┬────────┬──────────┐
│ Header │ 32B     │ Header │ 88B      │
│ size=32│ (used)  │ size=88│ (free)   │
└────────┴─────────┴────────┴──────────┘
```

## Part 8: Implementing free

### my_free()

```c
void my_free(void *ptr) {
    // NULL is valid (no-op)
    if (ptr == NULL) {
        return;
    }

    // Get block header
    block_header_t *block = (block_header_t*)ptr - 1;

    // Validate pointer (optional but recommended)
    if (ptr < heap_start || ptr >= heap_end) {
        fprintf(stderr, "free: invalid pointer %p\n", ptr);
        return;
    }

    if (block->is_free) {
        fprintf(stderr, "free: double free detected for %p\n", ptr);
        return;
    }

    // Update statistics
    stats.total_freed += block->size;
    stats.current_usage -= block->size;

    // Mark as free
    block->is_free = 1;

    // Coalesce with adjacent blocks
    coalesce_block(block);

    // Add to free list
    add_to_free_list(block);
}
```

## Part 9: Coalescing

### Finding Adjacent Blocks

To coalesce, we need to find adjacent blocks. This is tricky because blocks aren't in a linked list by address.

**Approach 1**: Traverse from heap start (slow)
**Approach 2**: Use address arithmetic

### Helper: Get Next Physical Block

```c
block_header_t *get_next_block(block_header_t *block) {
    // Calculate address of next block
    char *next_addr = (char*)(block + 1) + block->size;

    // Check if within heap
    if (next_addr >= (char*)heap_end) {
        return NULL;
    }

    return (block_header_t*)next_addr;
}
```

### Coalesce Forward

```c
void coalesce_block(block_header_t *block) {
    // Try to coalesce with next block
    block_header_t *next = get_next_block(block);

    if (next != NULL && next->is_free) {
        // Remove next from free list
        remove_from_free_list(next);

        // Merge blocks
        block->size += sizeof(block_header_t) + next->size;

        // Update statistics
        stats.num_blocks--;
    }

    // TODO: Coalesce backward (requires more work)
}
```

### Coalesce Backward (Advanced)

To coalesce backward, you need to find the previous block. Options:

**Option 1**: Boundary tags (footer with size)
```c
typedef struct {
    size_t size;  // Size at beginning
    // ... data ...
    size_t size;  // Size at end (footer)
} block_with_footer_t;
```

**Option 2**: Traverse from heap start (simple but slow)
```c
block_header_t *get_prev_block(block_header_t *block) {
    if (block == heap_start) {
        return NULL;
    }

    // Traverse from start (inefficient!)
    block_header_t *current = (block_header_t*)heap_start;

    while (current != NULL) {
        block_header_t *next = get_next_block(current);
        if (next == block) {
            return current;
        }
        current = next;
    }

    return NULL;
}
```

**Start simple**: Only coalesce forward. Add backward coalescing later if needed.

## Part 10: Advanced Functions

### my_realloc()

```c
void *my_realloc(void *ptr, size_t size) {
    // Handle special cases
    if (ptr == NULL) {
        return my_malloc(size);
    }

    if (size == 0) {
        my_free(ptr);
        return NULL;
    }

    // Get current block
    block_header_t *block = (block_header_t*)ptr - 1;
    size_t old_size = block->size;

    // Align new size
    size = ALIGN(size);

    // If new size fits in current block, done
    if (size <= old_size) {
        // Optionally split if much smaller
        if (old_size >= size + sizeof(block_header_t) + ALIGNMENT) {
            split_block(block, size);
        }
        return ptr;
    }

    // Need larger block - allocate new one
    void *new_ptr = my_malloc(size);
    if (new_ptr == NULL) {
        return NULL;
    }

    // Copy data to new block
    memcpy(new_ptr, ptr, old_size);

    // Free old block
    my_free(ptr);

    return new_ptr;
}
```

**Optimization**: Try to expand current block if next block is free and large enough.

### my_calloc()

```c
void *my_calloc(size_t nmemb, size_t size) {
    // Check for overflow
    size_t total = nmemb * size;
    if (nmemb != 0 && total / nmemb != size) {
        // Overflow
        return NULL;
    }

    // Allocate memory
    void *ptr = my_malloc(total);
    if (ptr == NULL) {
        return NULL;
    }

    // Zero the memory
    memset(ptr, 0, total);

    return ptr;
}
```

## Part 11: Debugging Utilities

### Print Heap

```c
void allocator_print_heap(void) {
    printf("=== Heap Layout ===\n");
    printf("Heap range: %p - %p\n", heap_start, heap_end);

    block_header_t *current = (block_header_t*)heap_start;
    int block_num = 0;

    while (current != NULL && (void*)current < heap_end) {
        printf("Block %d: %p\n", block_num++, (void*)current);
        printf("  Size: %zu bytes\n", current->size);
        printf("  Status: %s\n", current->is_free ? "FREE" : "ALLOCATED");
        printf("  Data at: %p\n", (void*)(current + 1));

        current = get_next_block(current);
    }

    printf("\n");
}
```

### Print Free List

```c
void allocator_print_free_list(void) {
    printf("=== Free List ===\n");

    block_header_t *current = free_list_head;
    int count = 0;

    while (current != NULL) {
        printf("Free block %d: %p (size: %zu)\n",
               count++, (void*)current, current->size);
        current = current->next;
    }

    printf("Total free blocks: %d\n\n", count);
}
```

### Print Statistics

```c
void allocator_print_stats(void) {
    printf("=== Allocator Statistics ===\n");
    printf("Total allocated:    %zu bytes\n", stats.total_allocated);
    printf("Total freed:        %zu bytes\n", stats.total_freed);
    printf("Current usage:      %zu bytes\n", stats.current_usage);
    printf("Peak usage:         %zu bytes\n", stats.peak_usage);
    printf("Number of blocks:   %zu\n", stats.num_blocks);
    printf("Free blocks:        %zu\n", stats.num_free_blocks);
    printf("\n");
}
```

### Integrity Check

```c
int allocator_check_integrity(void) {
    int errors = 0;

    // Check all blocks
    block_header_t *current = (block_header_t*)heap_start;

    while (current != NULL && (void*)current < heap_end) {
        // Check alignment
        if (((uintptr_t)current & (ALIGNMENT - 1)) != 0) {
            fprintf(stderr, "Error: Block %p not aligned\n", (void*)current);
            errors++;
        }

        // Check size is reasonable
        if (current->size == 0 || current->size > (size_t)heap_end - (size_t)current) {
            fprintf(stderr, "Error: Block %p has invalid size %zu\n",
                    (void*)current, current->size);
            errors++;
        }

        current = get_next_block(current);
    }

    // Check free list consistency
    block_header_t *free_current = free_list_head;
    while (free_current != NULL) {
        if (!free_current->is_free) {
            fprintf(stderr, "Error: Non-free block in free list: %p\n",
                    (void*)free_current);
            errors++;
        }
        free_current = free_current->next;
    }

    if (errors == 0) {
        printf("Integrity check passed!\n");
    } else {
        printf("Integrity check failed with %d errors\n", errors);
    }

    return errors == 0;
}
```

## Part 12: Testing

### Basic Test: test_basic.c

```c
#include "allocator.h"
#include <stdio.h>
#include <assert.h>
#include <string.h>

int main(void) {
    printf("Test 1: Basic allocation\n");
    void *p1 = my_malloc(100);
    assert(p1 != NULL);
    memset(p1, 'A', 100);  // Use the memory
    printf("  Allocated 100 bytes at %p\n", p1);

    printf("\nTest 2: Multiple allocations\n");
    void *p2 = my_malloc(200);
    void *p3 = my_malloc(50);
    assert(p2 && p3);
    printf("  Allocated 200 bytes at %p\n", p2);
    printf("  Allocated 50 bytes at %p\n", p3);

    printf("\nTest 3: Free and reuse\n");
    my_free(p1);
    void *p4 = my_malloc(80);  // Should reuse p1's block
    assert(p4 != NULL);
    printf("  Freed p1, allocated 80 bytes at %p\n", p4);

    printf("\nTest 4: calloc\n");
    int *arr = my_calloc(10, sizeof(int));
    assert(arr != NULL);
    for (int i = 0; i < 10; i++) {
        assert(arr[i] == 0);  // Should be zeroed
    }
    printf("  calloc'd array of 10 ints, all zero\n");

    printf("\nTest 5: realloc\n");
    arr = my_realloc(arr, 20 * sizeof(int));
    assert(arr != NULL);
    printf("  Reallocated array to 20 ints\n");

    allocator_print_stats();

    printf("\nAll tests passed!\n");
    return 0;
}
```

### Coalescing Test: test_coalesce.c

```c
#include "allocator.h"
#include <stdio.h>
#include <assert.h>

int main(void) {
    printf("Coalescing Test\n\n");

    // Allocate three adjacent blocks
    void *p1 = my_malloc(100);
    void *p2 = my_malloc(100);
    void *p3 = my_malloc(100);

    printf("Allocated three 100-byte blocks:\n");
    allocator_print_heap();

    // Free them in order - should coalesce
    printf("Freeing all three blocks...\n");
    my_free(p1);
    my_free(p2);
    my_free(p3);

    printf("\nAfter freeing (should show coalesced blocks):\n");
    allocator_print_heap();
    allocator_print_free_list();

    // Try to allocate large block - should fit in coalesced space
    void *p4 = my_malloc(250);
    assert(p4 != NULL);
    printf("Allocated 250 bytes (should reuse coalesced space)\n\n");

    allocator_print_stats();

    return 0;
}
```

### Stress Test: test_stress.c

```c
#include "allocator.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define NUM_OPERATIONS 1000
#define MAX_ALLOC_SIZE 1024

int main(void) {
    void *ptrs[NUM_OPERATIONS] = {NULL};
    srand(time(NULL));

    printf("Stress test: %d random operations\n", NUM_OPERATIONS);

    for (int i = 0; i < NUM_OPERATIONS; i++) {
        if (rand() % 2 && ptrs[i] == NULL) {
            // Allocate
            size_t size = (rand() % MAX_ALLOC_SIZE) + 1;
            ptrs[i] = my_malloc(size);

            if (ptrs[i] == NULL) {
                printf("Allocation failed at iteration %d\n", i);
            }
        } else if (ptrs[i] != NULL) {
            // Free
            my_free(ptrs[i]);
            ptrs[i] = NULL;
        }
    }

    // Free remaining
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        if (ptrs[i] != NULL) {
            my_free(ptrs[i]);
        }
    }

    printf("\nStress test complete!\n");
    allocator_print_stats();
    allocator_check_integrity();

    return 0;
}
```

## Exercises

### Exercise 1: Implement Best Fit

Replace first-fit with best-fit allocation. Compare performance and fragmentation.

### Exercise 2: Add Boundary Tags

Implement footers to enable backward coalescing. Test that it correctly merges:
```
[Free][Used][Free] → free middle → [Free][Free][Free] → [Large Free]
```

### Exercise 3: Segregated Free Lists

Maintain separate free lists for different size classes:
- Small: 1-32 bytes
- Medium: 33-256 bytes
- Large: 257+ bytes

### Exercise 4: Memory Debugging

Add features to detect:
- Buffer overflows (write past allocation)
- Use after free
- Memory leaks

Hints:
- Add magic numbers before/after data
- Track allocation source (file:line)
- Maintain list of all allocations

## Common Bugs and Debugging

### Bug 1: Segmentation Fault on Free

**Symptom**: Crash in `my_free()`

**Causes**:
- Invalid pointer (not from malloc)
- Double free
- Corrupted header

**Debug**: Add validation in free, print pointer value

### Bug 2: Memory Corruption

**Symptom**: Random crashes, corrupted data

**Causes**:
- Buffer overflow in user code
- Incorrect pointer arithmetic
- Missing alignment

**Debug**: Add integrity checks, magic numbers

### Bug 3: Memory Leak

**Symptom**: Increasing memory usage

**Causes**:
- Forgot to free
- Lost pointer to allocation

**Debug**: Track allocations, print stats

### Bug 4: Fragmentation

**Symptom**: malloc fails despite free memory

**Causes**:
- Many small free blocks
- Coalescing not working

**Debug**: Print heap layout, visualize fragments

## Milestone Checklist

- [ ] my_malloc() allocates memory
- [ ] my_free() releases memory
- [ ] Free list tracks available blocks
- [ ] First-fit finds suitable blocks
- [ ] Block splitting avoids waste
- [ ] Coalescing merges adjacent free blocks
- [ ] my_realloc() resizes allocations
- [ ] my_calloc() zeroes memory
- [ ] Alignment is correct
- [ ] No memory leaks
- [ ] Passes all tests
- [ ] Integrity checks pass

## Next Steps

Congratulations on implementing a memory allocator! In the final step, we'll focus on polishing, documentation, and presenting your work.
