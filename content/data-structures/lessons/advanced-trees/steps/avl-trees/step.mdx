---
id: avl-trees
title: AVL Trees
order: 1
---

# AVL Trees

AVL trees maintain a **balance factor** (height difference) of at most 1 between subtrees.

## AVL Node

```c
typedef struct AVLNode {
    int data;
    struct AVLNode *left;
    struct AVLNode *right;
    int height;
} AVLNode;

int getHeight(AVLNode *node) {
    return node ? node->height : 0;
}

int getBalance(AVLNode *node) {
    return node ? getHeight(node->left) - getHeight(node->right) : 0;
}

AVLNode *createAVLNode(int value) {
    AVLNode *node = (AVLNode *)malloc(sizeof(AVLNode));
    node->data = value;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

void updateHeight(AVLNode *node) {
    if (node) {
        node->height = 1 + max(getHeight(node->left), getHeight(node->right));
    }
}
```

## Rotations

```c
AVLNode *rightRotate(AVLNode *y) {
    AVLNode *x = y->left;
    AVLNode *T2 = x->right;

    x->right = y;
    y->left = T2;

    updateHeight(y);
    updateHeight(x);

    return x;
}

AVLNode *leftRotate(AVLNode *x) {
    AVLNode *y = x->right;
    AVLNode *T2 = y->left;

    y->left = x;
    x->right = T2;

    updateHeight(x);
    updateHeight(y);

    return y;
}
```

## Insert with Rebalancing

```c
AVLNode *avlInsert(AVLNode *node, int value) {
    if (node == NULL) {
        return createAVLNode(value);
    }

    if (value < node->data) {
        node->left = avlInsert(node->left, value);
    } else if (value > node->data) {
        node->right = avlInsert(node->right, value);
    } else {
        return node;  // No duplicates
    }

    updateHeight(node);
    int balance = getBalance(node);

    // Left Left Case
    if (balance > 1 && value < node->left->data) {
        return rightRotate(node);
    }

    // Right Right Case
    if (balance < -1 && value > node->right->data) {
        return leftRotate(node);
    }

    // Left Right Case
    if (balance > 1 && value > node->left->data) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance < -1 && value < node->right->data) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}
```

## AVL Properties

| Property                    | Value                        |
| --------------------------- | ---------------------------- |
| Height difference (balance) | At most 1                    |
| Minimum nodes for height h  | N(h) = N(h-1) + N(h-2) + 1   |
| Maximum height for n nodes  | ~1.44 \* logâ‚‚(n + 2) - 1.328 |
| Search/Insert/Delete        | O(log n) guaranteed          |
