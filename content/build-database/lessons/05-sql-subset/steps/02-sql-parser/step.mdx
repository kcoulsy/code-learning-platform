---
id: sql-parser
title: 'SQL Parser'
order: 2
---

# SQL Parser

## Prerequisites

- Completion of Lesson 5 Step 1: SQL Tokenizer
- Understanding of recursive descent parsing
- Knowledge of AST structures

## Learning Objectives

By the end of this step, you will:

- Implement a recursive descent parser
- Build Abstract Syntax Trees (ASTs)
- Parse SELECT, INSERT, CREATE TABLE statements
- Handle syntax errors gracefully

## Overview

The parser converts tokens into an AST:

- SELECT: columns, table, WHERE clause
- INSERT: table, values
- CREATE TABLE: table name, column definitions

## Implementation

### Parser Header (src/parser.h)

```c
#ifndef PARSER_H
#define PARSER_H

#include "tokenizer.h"
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif

// Statement types
typedef enum {
    STMT_SELECT,
    STMT_INSERT,
    STMT_UPDATE,
    STMT_DELETE,
    STMT_CREATE_TABLE,
    STMT_DROP_TABLE
} stmt_type_t;

// Column definition
typedef struct column_def {
    char name[64];
    token_type_t data_type;  // TOK_INTEGER, TOK_TEXT, etc.
    bool is_primary_key;
    bool is_nullable;
    struct column_def *next;
} column_def_t;

// Expression (for WHERE clause)
typedef enum {
    EXPR_LITERAL,
    EXPR_IDENTIFIER,
    EXPR_BINARY_OP
} expr_type_t;

typedef struct expr {
    expr_type_t type;
    union {
        // Literal
        struct {
            token_type_t lit_type;  // TOK_STRING, TOK_NUMBER, etc.
            char value[256];
        } literal;

        // Identifier
        char identifier[64];

        // Binary operation
        struct {
            token_type_t op;  // TOK_EQ, TOK_LT, etc.
            struct expr *left;
            struct expr *right;
        } binary;
    };
} expr_t;

// SELECT statement
typedef struct {
    char **columns;      // NULL for *
    int num_columns;
    char table[64];
    expr_t *where;       // NULL if no WHERE
} select_stmt_t;

// INSERT statement
typedef struct {
    char table[64];
    char **columns;      // NULL if not specified
    int num_columns;
    char **values;
    int num_values;
} insert_stmt_t;

// CREATE TABLE statement
typedef struct {
    char table[64];
    column_def_t *columns;
} create_table_stmt_t;

// Generic statement
typedef struct {
    stmt_type_t type;
    union {
        select_stmt_t select;
        insert_stmt_t insert;
        create_table_stmt_t create_table;
    };
} statement_t;

// Parse result
typedef struct {
    bool success;
    char error[256];
    int error_line;
    int error_column;
    statement_t statement;
} parse_result_t;

// Parse SQL string
parse_result_t parse(const char *sql);

// Free statement resources
void statement_free(statement_t *stmt);

// Print statement (for debugging)
void statement_print(const statement_t *stmt);

#ifdef __cplusplus
}
#endif

#endif // PARSER_H
```

### Parser Implementation (src/parser.c)

```c
#include "parser.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Parser state
typedef struct {
    tokenizer_t *tokenizer;
    token_t current;
    bool has_error;
    char error_msg[256];
    int error_line;
    int error_column;
} parser_t;

// Forward declarations
static expr_t *parse_expression(parser_t *p);
static parse_result_t make_error(parser_t *p, const char *msg);

// Initialize parser
static void parser_init(parser_t *p, const char *sql) {
    p->tokenizer = tokenizer_create(sql);
    p->current = tokenizer_next(p->tokenizer);
    p->has_error = false;
    p->error_msg[0] = '\0';
    p->error_line = 0;
    p->error_column = 0;
}

// Cleanup parser
static void parser_cleanup(parser_t *p) {
    tokenizer_destroy(p->tokenizer);
}

// Advance to next token
static void advance(parser_t *p) {
    p->current = tokenizer_next(p->tokenizer);
}

// Expect specific token type
static bool expect(parser_t *p, token_type_t type) {
    if (p->current.type == type) {
        advance(p);
        return true;
    }

    snprintf(p->error_msg, sizeof(p->error_msg),
             "Expected %s but got %s",
             token_type_name(type),
             token_type_name(p->current.type));
    p->error_line = p->current.line;
    p->error_column = p->current.column;
    p->has_error = true;
    return false;
}

// Check current token type
static bool check(parser_t *p, token_type_t type) {
    return p->current.type == type;
}

// Match and consume if type matches
static bool match(parser_t *p, token_type_t type) {
    if (check(p, type)) {
        advance(p);
        return true;
    }
    return false;
}

// ============================================================================
// EXPRESSION PARSING
// ============================================================================

static expr_t *create_expr(expr_type_t type) {
    expr_t *e = DB_MALLOC(sizeof(expr_t));
    if (e) {
        memset(e, 0, sizeof(expr_t));
        e->type = type;
    }
    return e;
}

static expr_t *parse_primary(parser_t *p) {
    if (check(p, TOK_IDENTIFIER)) {
        expr_t *e = create_expr(EXPR_IDENTIFIER);
        strcpy(e->identifier, p->current.text);
        advance(p);
        return e;
    }

    if (check(p, TOK_STRING) || check(p, TOK_NUMBER)) {
        expr_t *e = create_expr(EXPR_LITERAL);
        e->literal.lit_type = p->current.type;
        strcpy(e->literal.value, p->current.text);
        advance(p);
        return e;
    }

    return NULL;
}

static expr_t *parse_comparison(parser_t *p) {
    expr_t *left = parse_primary(p);
    if (!left) return NULL;

    // Check for comparison operator
    token_type_t op = p->current.type;
    if (op == TOK_EQ || op == TOK_LT || op == TOK_GT ||
        op == TOK_LE || op == TOK_GE || op == TOK_NE) {
        advance(p);

        expr_t *right = parse_primary(p);
        if (!right) {
            // Free left
            return NULL;
        }

        expr_t *e = create_expr(EXPR_BINARY_OP);
        e->binary.op = op;
        e->binary.left = left;
        e->binary.right = right;
        return e;
    }

    return left;
}

static expr_t *parse_expression(parser_t *p) {
    return parse_comparison(p);
}

// ============================================================================
// STATEMENT PARSING
// ============================================================================

static bool parse_select(parser_t *p, select_stmt_t *select) {
    // SELECT
    if (!expect(p, TOK_SELECT)) return false;

    // Column list or *
    if (match(p, TOK_STAR)) {
        select->columns = NULL;
        select->num_columns = 0;
    } else {
        // Parse column list
        select->num_columns = 0;
        select->columns = DB_MALLOC(sizeof(char *) * 16);

        do {
            if (!check(p, TOK_IDENTIFIER)) {
                return false;
            }
            select->columns[select->num_columns] = DB_STRDUP(p->current.text);
            select->num_columns++;
            advance(p);
        } while (match(p, TOK_COMMA));
    }

    // FROM
    if (!expect(p, TOK_FROM)) return false;

    // Table name
    if (!check(p, TOK_IDENTIFIER)) {
        return false;
    }
    strcpy(select->table, p->current.text);
    advance(p);

    // Optional WHERE
    if (match(p, TOK_WHERE)) {
        select->where = parse_expression(p);
        if (!select->where) {
            return false;
        }
    }

    return true;
}

static bool parse_insert(parser_t *p, insert_stmt_t *insert) {
    // INSERT INTO
    if (!expect(p, TOK_INSERT)) return false;
    if (!expect(p, TOK_INTO)) return false;

    // Table name
    if (!check(p, TOK_IDENTIFIER)) return false;
    strcpy(insert->table, p->current.text);
    advance(p);

    // Optional column list
    if (match(p, TOK_LPAREN)) {
        insert->columns = DB_MALLOC(sizeof(char *) * 16);
        insert->num_columns = 0;

        do {
            if (!check(p, TOK_IDENTIFIER)) return false;
            insert->columns[insert->num_columns] = DB_STRDUP(p->current.text);
            insert->num_columns++;
            advance(p);
        } while (match(p, TOK_COMMA));

        if (!expect(p, TOK_RPAREN)) return false;
    }

    // VALUES
    if (!expect(p, TOK_VALUES)) return false;
    if (!expect(p, TOK_LPAREN)) return false;

    // Value list
    insert->values = DB_MALLOC(sizeof(char *) * 16);
    insert->num_values = 0;

    do {
        if (check(p, TOK_STRING) || check(p, TOK_NUMBER) ||
            check(p, TOK_NULL) || check(p, TOK_TRUE) || check(p, TOK_FALSE)) {
            insert->values[insert->num_values] = DB_STRDUP(p->current.text);
            insert->num_values++;
            advance(p);
        } else {
            return false;
        }
    } while (match(p, TOK_COMMA));

    if (!expect(p, TOK_RPAREN)) return false;

    return true;
}

static bool parse_create_table(parser_t *p, create_table_stmt_t *create) {
    // CREATE TABLE
    if (!expect(p, TOK_CREATE)) return false;
    if (!expect(p, TOK_TABLE)) return false;

    // Table name
    if (!check(p, TOK_IDENTIFIER)) return false;
    strcpy(create->table, p->current.text);
    advance(p);

    // Column definitions
    if (!expect(p, TOK_LPAREN)) return false;

    column_def_t **tail = &create->columns;

    do {
        column_def_t *col = DB_MALLOC(sizeof(column_def_t));
        memset(col, 0, sizeof(column_def_t));

        // Column name
        if (!check(p, TOK_IDENTIFIER)) return false;
        strcpy(col->name, p->current.text);
        advance(p);

        // Data type
        if (check(p, TOK_INTEGER)) {
            col->data_type = TOK_INTEGER;
            advance(p);
        } else if (check(p, TOK_TEXT)) {
            col->data_type = TOK_TEXT;
            advance(p);
        } else {
            return false;
        }

        // Optional PRIMARY KEY
        if (match(p, TOK_PRIMARY)) {
            if (!expect(p, TOK_KEY)) return false;
            col->is_primary_key = true;
        }

        *tail = col;
        tail = &col->next;
    } while (match(p, TOK_COMMA));

    if (!expect(p, TOK_RPAREN)) return false;

    return true;
}

// ============================================================================
// PUBLIC INTERFACE
// ============================================================================

parse_result_t parse(const char *sql) {
    parse_result_t result;
    memset(&result, 0, sizeof(result));

    parser_t p;
    parser_init(&p, sql);

    // Parse based on first token
    switch (p.current.type) {
        case TOK_SELECT:
            result.statement.type = STMT_SELECT;
            result.success = parse_select(&p, &result.statement.select);
            break;

        case TOK_INSERT:
            result.statement.type = STMT_INSERT;
            result.success = parse_insert(&p, &result.statement.insert);
            break;

        case TOK_CREATE:
            result.statement.type = STMT_CREATE_TABLE;
            result.success = parse_create_table(&p, &result.statement.create_table);
            break;

        default:
            snprintf(p.error_msg, sizeof(p.error_msg),
                     "Unexpected token: %s", token_type_name(p.current.type));
            p.has_error = true;
            result.success = false;
    }

    if (!result.success) {
        strcpy(result.error, p.error_msg);
        result.error_line = p.error_line;
        result.error_column = p.error_column;
    }

    parser_cleanup(&p);
    return result;
}

void statement_free(statement_t *stmt) {
    if (!stmt) return;

    switch (stmt->type) {
        case STMT_SELECT:
            if (stmt->select.columns) {
                for (int i = 0; i < stmt->select.num_columns; i++) {
                    DB_FREE(stmt->select.columns[i]);
                }
                DB_FREE(stmt->select.columns);
            }
            // Free WHERE expression
            break;

        case STMT_INSERT:
            if (stmt->insert.columns) {
                for (int i = 0; i < stmt->insert.num_columns; i++) {
                    DB_FREE(stmt->insert.columns[i]);
                }
                DB_FREE(stmt->insert.columns);
            }
            if (stmt->insert.values) {
                for (int i = 0; i < stmt->insert.num_values; i++) {
                    DB_FREE(stmt->insert.values[i]);
                }
                DB_FREE(stmt->insert.values);
            }
            break;

        case STMT_CREATE_TABLE: {
            column_def_t *col = stmt->create_table.columns;
            while (col) {
                column_def_t *next = col->next;
                DB_FREE(col);
                col = next;
            }
            break;
        }

        default:
            break;
    }
}

void statement_print(const statement_t *stmt) {
    if (!stmt) return;

    switch (stmt->type) {
        case STMT_SELECT:
            printf("SELECT statement:\n");
            printf("  Table: %s\n", stmt->select.table);
            if (stmt->select.num_columns == 0) {
                printf("  Columns: *\n");
            } else {
                printf("  Columns: ");
                for (int i = 0; i < stmt->select.num_columns; i++) {
                    if (i > 0) printf(", ");
                    printf("%s", stmt->select.columns[i]);
                }
                printf("\n");
            }
            if (stmt->select.where) {
                printf("  WHERE: (expression)\n");
            }
            break;

        case STMT_INSERT:
            printf("INSERT statement:\n");
            printf("  Table: %s\n", stmt->insert.table);
            printf("  Values: ");
            for (int i = 0; i < stmt->insert.num_values; i++) {
                if (i > 0) printf(", ");
                printf("%s", stmt->insert.values[i]);
            }
            printf("\n");
            break;

        case STMT_CREATE_TABLE:
            printf("CREATE TABLE statement:\n");
            printf("  Table: %s\n", stmt->create_table.table);
            printf("  Columns:\n");
            column_def_t *col = stmt->create_table.columns;
            while (col) {
                printf("    %s %s%s\n",
                       col->name,
                       token_type_name(col->data_type),
                       col->is_primary_key ? " PRIMARY KEY" : "");
                col = col->next;
            }
            break;

        default:
            printf("Unknown statement type\n");
    }
}
```

## Hands-On Exercise

### Challenge: Parse SQL Statements

**Goal:** Test parser on various SQL

**Requirements:**

1. Parse: `SELECT * FROM users WHERE id = 42`
2. Parse: `INSERT INTO users VALUES (1, 'Alice')`
3. Parse: `CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)`
4. Verify AST structure

**Expected Output:**

```
Parsing: SELECT * FROM users WHERE id = 42
-------------------------------------------
SELECT statement:
  Table: users
  Columns: *
  WHERE: (expression)

Success!
```

## Next Steps

In the next step, you'll implement the **query execution engine** to run parsed SQL statements.
