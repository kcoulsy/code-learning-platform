---
title: "malloc() Basics"
order: 2
---

# malloc() Basics

The `malloc()` function (memory allocation) is your primary tool for allocating memory on the heap. Understanding how to use it correctly is fundamental to C programming.

## The malloc() Function

```c
void *malloc(size_t size);
```

- **Parameter**: Number of bytes to allocate
- **Returns**: Pointer to allocated memory, or `NULL` if allocation fails
- **Header**: `<stdlib.h>`
- **Returns `void*`**: Can be cast to any pointer type

## Understanding Stack vs Heap: A Mental Model

**Think of it like this:** Memory allocation is like parking your car.

**Stack (Automatic Variables):**
- Like **valet parking** - the valet (compiler) handles everything automatically
- You drive up (enter function), they park your car (allocate variable)
- You leave (exit function), they return your car and the spot opens up (automatic deallocation)
- **Fast and automatic**, but limited space and no control over lifetime
- Variables die when function returns

```c
void function() {
    int x = 10;  // Stack allocation - automatic
    // x dies when function returns
}
```

**Heap (Dynamic Memory):**
- Like **self-parking** - you find a spot and manage it yourself
- You `malloc()` to claim a spot (allocate memory)
- You must `free()` when done or the spot stays claimed forever (memory leak)
- **Slower but flexible** - control size and lifetime, can return pointers from functions
- Memory persists until you explicitly free it

```c
int *ptr = malloc(sizeof(int));  // Heap allocation - manual
*ptr = 10;
// ptr persists until you free(ptr)
```

**Visual representation:**
```
Stack (grows downward):          Heap (grows upward):
┌─────────────────┐             ┌─────────────────┐
│ function vars   │             │ malloc'd blocks │
│ (automatic)     │             │ (manual)        │
│ - x (int)       │             │ - ptr→ [data]  │
│ - y (float)     │             │ - arr→ [array] │
├─────────────────┤             ├─────────────────┤
│ function returns│             │ remains until   │
│ → memory freed  │             │ you free() it   │
└─────────────────┘             └─────────────────┘

Stack: Fast, automatic, limited    Heap: Flexible, manual, larger
```

**Key insight:**
- **Stack is LIFO** (Last-In-First-Out) - like a stack of plates
- **Heap is a big pool** - you can allocate/free in any order
- **Stack overflow** = too much recursion or huge local arrays
- **Memory leak** = forgetting to `free()` heap memory
- **Dangling pointer** = using heap pointer after `free()`

**This explains why:**
- You can't return a pointer to a local variable (stack memory dies)
- You CAN return a malloc'd pointer (heap memory persists)
- Arrays of unknown size need malloc (stack size is fixed at compile-time)
- You must manually free heap memory (no automatic cleanup)

## Basic Usage

Here's the fundamental pattern you'll use thousands of times:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocate memory for one integer
    int *ptr = malloc(sizeof(int));

    // ALWAYS check if allocation succeeded
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    // Use the allocated memory
    *ptr = 42;
    printf("Value: %d\n", *ptr);

    // ALWAYS free when done
    free(ptr);

    return 0;
}
```

## Why sizeof() is Critical

**Never hardcode sizes!** Always use `sizeof()` to ensure portability:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // WRONG - assumes int is 4 bytes
    int *wrong = malloc(4);

    // RIGHT - portable across all systems
    int *right = malloc(sizeof(int));

    if (right == NULL) {
        printf("Allocation failed!\n");
        return 1;
    }

    printf("Size of int on this system: %zu bytes\n", sizeof(int));

    free(right);
    // free(wrong);  // Should free this too, but don't use this pattern!

    return 0;
}
```

## Allocating Arrays

One of the most common uses of `malloc()` is allocating arrays:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 5;

    // Allocate array of n integers
    int *arr = malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("Failed to allocate memory for %d integers\n", n);
        return 1;
    }

    // Initialize array
    for (int i = 0; i < n; i++) {
        arr[i] = i * 10;
    }

    // Use array
    printf("Array contents: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Free the entire array with one call
    free(arr);

    return 0;
}
```

## Allocating Structures

`malloc()` works with any data type, including structures:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    int age;
    float gpa;
} Student;

int main() {
    // Allocate memory for one Student
    Student *student = malloc(sizeof(Student));

    if (student == NULL) {
        printf("Allocation failed!\n");
        return 1;
    }

    // Initialize the structure
    strcpy(student->name, "Alice");
    student->age = 20;
    student->gpa = 3.8;

    printf("Student: %s, Age: %d, GPA: %.2f\n",
           student->name, student->age, student->gpa);

    free(student);

    // Allocate array of Students
    int num_students = 3;
    Student *class = malloc(num_students * sizeof(Student));

    if (class == NULL) {
        printf("Allocation failed!\n");
        return 1;
    }

    // Initialize array
    for (int i = 0; i < num_students; i++) {
        sprintf(class[i].name, "Student %d", i + 1);
        class[i].age = 18 + i;
        class[i].gpa = 3.0 + i * 0.2;
    }

    // Display array
    for (int i = 0; i < num_students; i++) {
        printf("%s: Age %d, GPA %.2f\n",
               class[i].name, class[i].age, class[i].gpa);
    }

    free(class);

    return 0;
}
```

## Debugging: Error Messages You'll See

### Error: `error: invalid conversion from 'void*' to 'int*'`

**What it means:** You're compiling C code with a C++ compiler. In C++, malloc needs explicit casting.

**Example (C++ compiler):**
```c
int *ptr = malloc(sizeof(int));  // Error in C++
```

**How to fix:**
- Use `.c` extension and compile with `gcc` (not `g++`)
- OR cast in C++: `int *ptr = (int*)malloc(sizeof(int));` (but prefer `new` in C++)

### Error: `undefined reference to 'malloc'`

**What it means:** Very rare, but means stdlib isn't linked properly.

**How to fix:** Make sure you have `#include <stdlib.h>` at the top of your file.

### Error: `error: 'malloc' was not declared in this scope`

**What it means:** Missing include.

**How to fix:**
```c
#include <stdlib.h>  // Add this at the top
```

### Runtime Error: Segmentation Fault (from NULL dereference)

**What happens:** malloc failed (returned NULL), and you didn't check before using the pointer.

**Example:**
```c
int *ptr = malloc(99999999999 * sizeof(int));  // Too much memory!
*ptr = 42;  // CRASH! ptr is NULL
```

**What you'll see:**
```
Segmentation fault (core dumped)
```

**How to prevent:**
```c
int *ptr = malloc(size);
if (ptr == NULL) {
    fprintf(stderr, "Memory allocation failed!\n");
    return 1;  // Exit gracefully
}
// Safe to use ptr now
```

### Valgrind Output: Definitely Lost

**What it means:** You allocated memory but never freed it (memory leak).

**Example:**
```c
void function() {
    int *leak = malloc(sizeof(int));
    *leak = 42;
    // Oops, forgot to free(leak)!
}  // Memory leaked!
```

**Valgrind output:**
```
$ valgrind --leak-check=full ./program

==12345== HEAP SUMMARY:
==12345==     in use at exit: 4 bytes in 1 blocks
==12345==   total heap usage: 1 allocs, 0 frees, 4 bytes allocated
==12345==
==12345== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==12345==    by 0x400537: function (program.c:8)
==12345==    by 0x400567: main (program.c:15)
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 4 bytes in 1 blocks
```

**How to read this:**
- `4 bytes in 1 blocks are definitely lost` - You leaked 4 bytes (one int)
- `by 0x400537: function (program.c:8)` - The leak happened at line 8 in function()
- `definitely lost` = Memory you can never free (lost all references)

**The fix:**
```c
void function() {
    int *leak = malloc(sizeof(int));
    *leak = 42;
    free(leak);  // Clean up before returning
}
```

### Valgrind Output: Invalid Write

**What it means:** You wrote past the end of allocated memory (buffer overflow).

**Example:**
```c
int *arr = malloc(5 * sizeof(int));
arr[10] = 42;  // Out of bounds! Only indices 0-4 are valid
```

**Valgrind output:**
```
==12345== Invalid write of size 4
==12345==    at 0x400567: main (program.c:12)
==12345==  Address 0x520d068 is 20 bytes inside a block of size 20 alloc'd
```

**How to fix:** Check your array indices - make sure you stay within bounds.

### AddressSanitizer Output: Heap-buffer-overflow

**What it means:** Similar to valgrind, but faster detection. You accessed memory outside malloc'd bounds.

**How to use:**
```bash
gcc -fsanitize=address -g program.c -o program
./program
```

**Example output:**
```
=================================================================
==12345==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000014
WRITE of size 4 at 0x602000000014 thread T0
    #0 0x400567 in main program.c:12
```

**How to fix:** Review the line indicated (program.c:12) and check array bounds.

## Why This Matters

**In real code:**
- **Databases** use malloc for query result buffers
- **Web servers** allocate memory for incoming requests
- **Image processing** loads images into malloc'd buffers
- **Compilers** build parse trees and symbol tables on the heap
- **Any program** that doesn't know data size until runtime

**What breaks if you get malloc wrong:**
- **Memory leaks** - Your program consumes more and more RAM until it's killed
- **Crashes** - Dereferencing NULL after failed malloc
- **Security vulnerabilities** - Buffer overflows in heap memory can be exploited
- **Undefined behavior** - Using memory after free() causes unpredictable bugs

**Professional practice:**
- Always check for NULL
- Always free what you allocate
- Use valgrind or AddressSanitizer during development
- Pair every malloc with a free (use comments to track)
- Consider using ownership patterns (who's responsible for freeing?)

## Common malloc() Patterns and Pitfalls

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Pattern 1: Always check return value
    int *ptr1 = malloc(sizeof(int));
    if (ptr1 == NULL) {
        fprintf(stderr, "Allocation failed!\n");
        return 1;
    }
    free(ptr1);

    // Pattern 2: Don't cast malloc (in C)
    // Modern C doesn't require casting malloc's return value
    int *ptr2 = malloc(sizeof(int));  // Preferred
    // int *ptr3 = (int*)malloc(sizeof(int));  // Works but unnecessary in C
    if (ptr2 == NULL) {
        return 1;
    }
    free(ptr2);

    // Pattern 3: Use sizeof with the variable type
    int *ptr4 = malloc(sizeof(int));  // OK
    int *ptr5 = malloc(sizeof(*ptr5));  // Better - maintains consistency if type changes
    if (ptr4 == NULL || ptr5 == NULL) {
        return 1;
    }
    free(ptr4);
    free(ptr5);

    // Pattern 4: Be careful with overflow
    size_t n = 1000000;
    size_t size = n * sizeof(int);

    // Check for integer overflow (advanced)
    if (size / sizeof(int) != n) {
        fprintf(stderr, "Size calculation overflowed!\n");
        return 1;
    }

    int *large_array = malloc(size);
    if (large_array == NULL) {
        fprintf(stderr, "Failed to allocate %zu bytes\n", size);
        return 1;
    }

    printf("Successfully allocated %zu bytes for %zu integers\n", size, n);
    free(large_array);

    // PITFALL: Not freeing memory
    int *leak = malloc(sizeof(int));  // Memory leak if we don't free
    if (leak != NULL) {
        *leak = 100;
        // Oops, forgot to free(leak)!
    }

    // PITFALL: Using malloc without checking
    // int *danger = malloc(sizeof(int));
    // *danger = 42;  // CRASH if malloc returned NULL!

    return 0;
}
```

## Critical Gotcha: Forgetting to Check for NULL

**Why it happens:** malloc can fail! You might run out of memory, or request too much at once.

**The bug:**
```c
int *ptr = malloc(sizeof(int));
*ptr = 42;  // CRASH if malloc returned NULL!
printf("%d\n", *ptr);
```

**Why it's dangerous:**
- On small allocations, malloc rarely fails (giving false confidence)
- On larger allocations or low-memory systems, it WILL fail
- Dereferencing NULL causes immediate crash
- Your program might work in development, fail in production

**What you'll see:**
```
Segmentation fault (core dumped)
```

**The fix - ALWAYS check:**
```c
int *ptr = malloc(sizeof(int));
if (ptr == NULL) {
    fprintf(stderr, "Error: Memory allocation failed\n");
    return 1;  // Or handle error appropriately
}
// Now safe to use ptr
*ptr = 42;
printf("%d\n", *ptr);
free(ptr);
```

**Professional pattern:**
```c
// Defensive allocation wrapper
int *safe_malloc_int(void) {
    int *ptr = malloc(sizeof(int));
    if (ptr == NULL) {
        fprintf(stderr, "Fatal: Out of memory\n");
        exit(1);
    }
    return ptr;
}

// Usage
int *ptr = safe_malloc_int();  // Will exit if allocation fails
*ptr = 42;  // Safe - guaranteed non-NULL
```

**Prevention:**
- Make NULL checking a habit (do it EVERY time)
- Use compiler warnings: `-Wall -Wextra`
- Use static analysis tools: `clang --analyze`
- Test with artificial memory limits: `ulimit -v 100000` (Linux)
- Consider wrapper functions that handle errors consistently

**Real-world context:** In server software, malloc failures can happen under load. A missed NULL check can crash your entire server instead of gracefully rejecting one request.
```

## The Golden Rules of malloc()

1. **Always use `sizeof()`** - Never hardcode sizes
2. **Always check the return value** - `NULL` means failure
3. **Always free what you allocate** - One `malloc()` = one `free()`
4. **Use `sizeof(*ptr)`** - More maintainable than `sizeof(type)`
5. **Handle allocation failure gracefully** - Don't crash, clean up and exit

## A Complete Safe Allocation Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Safe string duplication function
char *safe_strdup(const char *str) {
    if (str == NULL) {
        return NULL;
    }

    size_t len = strlen(str) + 1;  // +1 for null terminator
    char *copy = malloc(len * sizeof(char));

    if (copy == NULL) {
        return NULL;  // Allocation failed
    }

    memcpy(copy, str, len);
    return copy;
}

int main() {
    const char *original = "Hello, malloc!";

    char *copy = safe_strdup(original);
    if (copy == NULL) {
        fprintf(stderr, "Failed to duplicate string\n");
        return 1;
    }

    printf("Original: %s\n", original);
    printf("Copy:     %s\n", copy);

    // Modify copy without affecting original
    copy[0] = 'J';
    printf("Modified: %s\n", copy);
    printf("Original: %s\n", original);

    free(copy);

    return 0;
}
```

## Key Takeaways

1. **`malloc(size)`** allocates `size` bytes on the heap
2. **Always use `sizeof()`** to calculate sizes portably
3. **Check for `NULL`** - allocation can fail
4. **Free every allocation** - prevent memory leaks
5. **`malloc()` doesn't initialize memory** - it contains garbage values
6. **Use `sizeof(*ptr)`** pattern for maintainability

## Exercises

1. Write a function that allocates and returns an array of `n` integers, returning `NULL` on failure
2. Create a program that allocates memory for 100 integers and initializes them to their indices
3. Write a safe string copy function that allocates memory for the copy
4. Allocate memory for an array of structures and initialize them
5. What happens if you try to allocate 0 bytes? Test it!
6. Write a function that reads a line of unknown length from stdin by repeatedly allocating memory

In the next step, we'll explore `calloc()` and `realloc()`, which provide additional allocation capabilities.
