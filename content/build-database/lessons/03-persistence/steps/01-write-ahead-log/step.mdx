---
id: write-ahead-log
title: 'Write-Ahead Log (WAL)'
order: 1
---

# Write-Ahead Log (WAL)

## Prerequisites

- Completion of Lesson 2: In-Memory Key-Value Store
- Understanding of file I/O in C
- Knowledge of binary data formats

## Learning Objectives

By the end of this step, you will:

- Understand the Write-Ahead Log pattern
- Implement binary log file format
- Write durable append-only logs
- Handle file I/O errors gracefully
- Ensure data integrity with checksums

## Overview

A Write-Ahead Log (WAL) ensures durability: every change is written to disk before being applied to memory. If the system crashes, we can replay the log to recover.

### Why WAL?

1. **Durability:** Changes survive crashes
2. **Atomicity:** Log entries are atomic
3. **Recovery:** Replay log to restore state
4. **Performance:** Sequential writes are fast

## Complete Implementation

### 1. WAL Header (src/wal.h)

```c
#ifndef WAL_H
#define WAL_H

#include "utils.h"
#include "kv_store.h"

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// CONSTANTS
// ============================================================================

#define WAL_MAGIC 0x57414C21  // "WAL!" in hex
#define WAL_VERSION 1
#define WAL_FILENAME "wal.log"
#define WAL_MAX_KEY_SIZE 65535
#define WAL_MAX_VALUE_SIZE 16777215  // 16MB

// ============================================================================
// OPERATION TYPES
// ============================================================================

typedef enum {
    WAL_OP_SET = 1,
    WAL_OP_DELETE = 2,
    WAL_OP_CLEAR = 3,
    WAL_OP_CHECKPOINT = 4
} wal_op_type_t;

// ============================================================================
// LOG ENTRY HEADER
// ============================================================================

// Packed structure for on-disk format
#pragma pack(push, 1)
typedef struct {
    uint32_t magic;             // Magic number for validation
    uint16_t version;           // WAL format version
    uint8_t  op_type;           // Operation type
    uint32_t checksum;          // CRC32 of payload
    uint64_t timestamp;         // Unix timestamp (microseconds)
    uint32_t sequence;          // Monotonic sequence number
    uint16_t key_len;           // Key length (0 for CLEAR)
    uint32_t value_len;         // Value length (0 for DELETE)
    // Followed by: key bytes, value bytes
} wal_entry_header_t;
#pragma pack(pop)

// ============================================================================
// WAL STRUCTURE
// ============================================================================

typedef struct wal wal_t;

// ============================================================================
// LIFECYCLE
// ============================================================================

// Open or create a WAL file
// Returns NULL on error
wal_t *wal_open(const char *filename);

// Close WAL and free resources
void wal_close(wal_t *wal);

// Sync WAL to disk (fsync)
db_error_t wal_sync(wal_t *wal);

// ============================================================================
// LOGGING OPERATIONS
// ============================================================================

// Append a SET operation to the log
db_error_t wal_log_set(wal_t *wal, const char *key, const value_t *value);

// Append a DELETE operation to the log
db_error_t wal_log_delete(wal_t *wal, const char *key);

// Append a CLEAR operation to the log
db_error_t wal_log_clear(wal_t *wal);

// Append a CHECKPOINT marker
db_error_t wal_log_checkpoint(wal_t *wal, uint64_t checkpoint_id);

// ============================================================================
// RECOVERY
// ============================================================================

// Callback function for recovery
typedef void (*wal_recovery_cb)(wal_op_type_t op, const char *key,
                                 const value_t *value, uint64_t timestamp,
                                 uint32_t sequence, void *ctx);

// Recover from WAL file
// Calls callback for each valid entry
// Returns number of entries recovered, or -1 on error
int wal_recover(const char *filename, wal_recovery_cb callback, void *ctx);

// Validate WAL file integrity
// Returns true if file is valid
bool wal_validate(const char *filename);

// ============================================================================
// STATISTICS
// ============================================================================

typedef struct {
    uint64_t total_entries;     // Total entries in WAL
    uint64_t set_ops;           // Number of SET operations
    uint64_t delete_ops;        // Number of DELETE operations
    uint64_t clear_ops;         // Number of CLEAR operations
    uint64_t corrupt_entries;   // Number of corrupt entries skipped
    uint64_t file_size;         // Total file size in bytes
} wal_stats_t;

// Get WAL statistics
void wal_get_stats(wal_t *wal, wal_stats_t *stats);

// Print WAL statistics
void wal_print_stats(wal_t *wal);

#ifdef __cplusplus
}
#endif

#endif // WAL_H
```

### 2. WAL Implementation (src/wal.c)

```c
#include "wal.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>
#include <stdint.h>

// Simple CRC32 implementation
static uint32_t crc32_table[256];
static int crc32_initialized = 0;

static void init_crc32(void) {
    if (crc32_initialized) return;

    for (uint32_t i = 0; i < 256; i++) {
        uint32_t crc = i;
        for (int j = 0; j < 8; j++) {
            crc = (crc >> 1) ^ (0xEDB88320 & -(crc & 1));
        }
        crc32_table[i] = crc;
    }
    crc32_initialized = 1;
}

static uint32_t calculate_crc32(const uint8_t *data, size_t len) {
    init_crc32();
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc = (crc >> 8) ^ crc32_table[(crc ^ data[i]) & 0xFF];
    }
    return ~crc;
}

// ============================================================================
// WAL STRUCTURE
// ============================================================================

struct wal {
    int fd;                     // File descriptor
    char *filename;             // Filename (for reopening)
    uint32_t next_sequence;     // Next sequence number
    wal_stats_t stats;          // Statistics
};

// ============================================================================
// LIFECYCLE
// ============================================================================

wal_t *wal_open(const char *filename) {
    if (!filename) {
        db_error("wal_open: NULL filename");
        return NULL;
    }

    wal_t *wal = DB_MALLOC(sizeof(wal_t));
    if (!wal) {
        return NULL;
    }

    wal->filename = DB_STRDUP(filename);
    if (!wal->filename) {
        DB_FREE(wal);
        return NULL;
    }

    // Open file for append, create if doesn't exist
    wal->fd = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (wal->fd < 0) {
        db_error("wal_open: failed to open %s: %s", filename, strerror(errno));
        DB_FREE(wal->filename);
        DB_FREE(wal);
        return NULL;
    }

    wal->next_sequence = 1;
    memset(&wal->stats, 0, sizeof(wal_stats_t));

    db_info("WAL opened: %s", filename);
    return wal;
}

void wal_close(wal_t *wal) {
    if (!wal) return;

    if (wal->fd >= 0) {
        // Sync before closing
        fsync(wal->fd);
        close(wal->fd);
    }

    DB_FREE(wal->filename);
    DB_FREE(wal);

    db_info("WAL closed");
}

db_error_t wal_sync(wal_t *wal) {
    if (!wal || wal->fd < 0) {
        return DB_ERROR_INVALID;
    }

    if (fsync(wal->fd) != 0) {
        db_error("wal_sync failed: %s", strerror(errno));
        return DB_ERROR_IO;
    }

    return DB_OK;
}

// ============================================================================
// SERIALIZATION HELPERS
// ============================================================================

static db_error_t serialize_value(const value_t *value, uint8_t **out_data,
                                   size_t *out_len) {
    if (!value || !out_data || !out_len) {
        return DB_ERROR_INVALID;
    }

    // Calculate size needed
    size_t size = 1;  // Type byte

    switch (value->type) {
        case VALUE_TYPE_NULL:
            break;
        case VALUE_TYPE_INT:
            size += sizeof(int64_t);
            break;
        case VALUE_TYPE_FLOAT:
            size += sizeof(double);
            break;
        case VALUE_TYPE_STRING:
            if (value->data.string_val) {
                size += strlen(value->data.string_val) + 1;  // Include null
            }
            break;
        case VALUE_TYPE_BLOB:
            size += sizeof(uint32_t) + value->data.blob_val.size;
            break;
        case VALUE_TYPE_BOOL:
            size += 1;
            break;
        default:
            return DB_ERROR_INVALID;
    }

    // Allocate buffer
    uint8_t *data = DB_MALLOC(size);
    if (!data) {
        return DB_ERROR_NOMEM;
    }

    // Serialize
    size_t pos = 0;
    data[pos++] = (uint8_t)value->type;

    switch (value->type) {
        case VALUE_TYPE_NULL:
            break;
        case VALUE_TYPE_INT:
            memcpy(data + pos, &value->data.int_val, sizeof(int64_t));
            pos += sizeof(int64_t);
            break;
        case VALUE_TYPE_FLOAT:
            memcpy(data + pos, &value->data.float_val, sizeof(double));
            pos += sizeof(double);
            break;
        case VALUE_TYPE_STRING:
            if (value->data.string_val) {
                size_t len = strlen(value->data.string_val) + 1;
                memcpy(data + pos, value->data.string_val, len);
                pos += len;
            }
            break;
        case VALUE_TYPE_BLOB: {
            uint32_t blob_size = value->data.blob_val.size;
            memcpy(data + pos, &blob_size, sizeof(uint32_t));
            pos += sizeof(uint32_t);
            if (blob_size > 0) {
                memcpy(data + pos, value->data.blob_val.data, blob_size);
                pos += blob_size;
            }
            break;
        }
        case VALUE_TYPE_BOOL:
            data[pos++] = value->data.bool_val ? 1 : 0;
            break;
    }

    *out_data = data;
    *out_len = pos;
    return DB_OK;
}

static db_error_t deserialize_value(const uint8_t *data, size_t len,
                                     value_t *out_value) {
    if (!data || len == 0 || !out_value) {
        return DB_ERROR_INVALID;
    }

    memset(out_value, 0, sizeof(value_t));
    out_value->type = (value_type_t)data[0];

    size_t pos = 1;

    switch (out_value->type) {
        case VALUE_TYPE_NULL:
            break;
        case VALUE_TYPE_INT:
            if (pos + sizeof(int64_t) > len) return DB_ERROR_INVALID;
            memcpy(&out_value->data.int_val, data + pos, sizeof(int64_t));
            break;
        case VALUE_TYPE_FLOAT:
            if (pos + sizeof(double) > len) return DB_ERROR_INVALID;
            memcpy(&out_value->data.float_val, data + pos, sizeof(double));
            break;
        case VALUE_TYPE_STRING:
            if (pos < len) {
                size_t str_len = len - pos;
                out_value->data.string_val = DB_MALLOC(str_len);
                if (!out_value->data.string_val) {
                    return DB_ERROR_NOMEM;
                }
                memcpy(out_value->data.string_val, data + pos, str_len);
            }
            break;
        case VALUE_TYPE_BLOB:
            if (pos + sizeof(uint32_t) > len) return DB_ERROR_INVALID;
            uint32_t blob_size;
            memcpy(&blob_size, data + pos, sizeof(uint32_t));
            pos += sizeof(uint32_t);
            if (blob_size > 0) {
                if (pos + blob_size > len) return DB_ERROR_INVALID;
                out_value->data.blob_val.data = DB_MALLOC(blob_size);
                if (!out_value->data.blob_val.data) {
                    return DB_ERROR_NOMEM;
                }
                memcpy(out_value->data.blob_val.data, data + pos, blob_size);
                out_value->data.blob_val.size = blob_size;
            }
            break;
        case VALUE_TYPE_BOOL:
            if (pos < len) {
                out_value->data.bool_val = data[pos] != 0;
            }
            break;
        default:
            return DB_ERROR_INVALID;
    }

    return DB_OK;
}

// ============================================================================
// LOGGING OPERATIONS
// ============================================================================

static db_error_t write_entry(wal_t *wal, wal_op_type_t op, const char *key,
                               const value_t *value) {
    if (!wal || wal->fd < 0) {
        return DB_ERROR_INVALID;
    }

    uint16_t key_len = key ? strlen(key) : 0;

    // Serialize value
    uint8_t *value_data = NULL;
    size_t value_data_len = 0;

    if (value) {
        db_error_t err = serialize_value(value, &value_data, &value_data_len);
        if (err != DB_OK) {
            return err;
        }
    }

    // Calculate payload for checksum
    size_t payload_len = sizeof(uint16_t) + key_len + value_data_len;
    uint8_t *payload = DB_MALLOC(payload_len);
    if (!payload) {
        DB_FREE(value_data);
        return DB_ERROR_NOMEM;
    }

    size_t pos = 0;
    memcpy(payload + pos, &key_len, sizeof(uint16_t));
    pos += sizeof(uint16_t);
    if (key_len > 0) {
        memcpy(payload + pos, key, key_len);
        pos += key_len;
    }
    if (value_data_len > 0) {
        memcpy(payload + pos, value_data, value_data_len);
        pos += value_data_len;
    }

    // Build header
    wal_entry_header_t header;
    memset(&header, 0, sizeof(header));
    header.magic = WAL_MAGIC;
    header.version = WAL_VERSION;
    header.op_type = (uint8_t)op;
    header.checksum = calculate_crc32(payload, payload_len);
    header.timestamp = (uint64_t)time(NULL) * 1000000ULL;  // microseconds
    header.sequence = wal->next_sequence++;
    header.key_len = key_len;
    header.value_len = (uint32_t)value_data_len;

    // Write header
    ssize_t written = write(wal->fd, &header, sizeof(header));
    if (written != sizeof(header)) {
        db_error("wal: failed to write header: %s", strerror(errno));
        DB_FREE(payload);
        DB_FREE(value_data);
        return DB_ERROR_IO;
    }

    // Write payload
    written = write(wal->fd, payload, payload_len);
    if (written != (ssize_t)payload_len) {
        db_error("wal: failed to write payload: %s", strerror(errno));
        DB_FREE(payload);
        DB_FREE(value_data);
        return DB_ERROR_IO;
    }

    // Sync to ensure durability
    fsync(wal->fd);

    // Update stats
    wal->stats.total_entries++;
    switch (op) {
        case WAL_OP_SET: wal->stats.set_ops++; break;
        case WAL_OP_DELETE: wal->stats.delete_ops++; break;
        case WAL_OP_CLEAR: wal->stats.clear_ops++; break;
        default: break;
    }

    DB_FREE(payload);
    DB_FREE(value_data);

    db_debug("WAL: logged %s seq=%u key='%s'",
             op == WAL_OP_SET ? "SET" : "DELETE",
             header.sequence, key ? key : "(null)");

    return DB_OK;
}

db_error_t wal_log_set(wal_t *wal, const char *key, const value_t *value) {
    if (!key || !value) {
        return DB_ERROR_INVALID;
    }
    return write_entry(wal, WAL_OP_SET, key, value);
}

db_error_t wal_log_delete(wal_t *wal, const char *key) {
    if (!key) {
        return DB_ERROR_INVALID;
    }
    return write_entry(wal, WAL_OP_DELETE, key, NULL);
}

db_error_t wal_log_clear(wal_t *wal) {
    return write_entry(wal, WAL_OP_CLEAR, NULL, NULL);
}

db_error_t wal_log_checkpoint(wal_t *wal, uint64_t checkpoint_id) {
    (void)checkpoint_id;
    // Implementation for checkpoint marker
    return DB_OK;
}

// ============================================================================
// RECOVERY
// ============================================================================

int wal_recover(const char *filename, wal_recovery_cb callback, void *ctx) {
    if (!filename || !callback) {
        return -1;
    }

    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        if (errno == ENOENT) {
            // File doesn't exist - nothing to recover
            return 0;
        }
        db_error("wal_recover: failed to open %s: %s", filename, strerror(errno));
        return -1;
    }

    int entry_count = 0;
    int corrupt_count = 0;

    while (1) {
        wal_entry_header_t header;
        ssize_t n = read(fd, &header, sizeof(header));

        if (n == 0) {
            // EOF
            break;
        }

        if (n != sizeof(header)) {
            db_warn("wal_recover: incomplete header at offset %ld",
                    (long)lseek(fd, 0, SEEK_CUR) - n);
            corrupt_count++;
            break;
        }

        // Validate header
        if (header.magic != WAL_MAGIC) {
            db_warn("wal_recover: invalid magic at offset %ld",
                    (long)lseek(fd, 0, SEEK_CUR) - sizeof(header));
            corrupt_count++;
            break;
        }

        if (header.version != WAL_VERSION) {
            db_warn("wal_recover: unsupported version %u", header.version);
            corrupt_count++;
            break;
        }

        // Read payload
        size_t payload_len = sizeof(uint16_t) + header.key_len + header.value_len;
        uint8_t *payload = DB_MALLOC(payload_len);
        if (!payload) {
            close(fd);
            return -1;
        }

        n = read(fd, payload, payload_len);
        if (n != (ssize_t)payload_len) {
            db_warn("wal_recover: incomplete payload");
            DB_FREE(payload);
            corrupt_count++;
            break;
        }

        // Verify checksum
        uint32_t calc_checksum = calculate_crc32(payload, payload_len);
        if (calc_checksum != header.checksum) {
            db_warn("wal_recover: checksum mismatch at seq=%u", header.sequence);
            DB_FREE(payload);
            corrupt_count++;
            continue;  // Skip corrupt entry but continue
        }

        // Parse payload
        char *key = NULL;
        value_t value;
        memset(&value, 0, sizeof(value));

        size_t pos = 0;

        if (header.key_len > 0) {
            key = DB_MALLOC(header.key_len + 1);
            memcpy(key, payload + sizeof(uint16_t), header.key_len);
            key[header.key_len] = '\0';
            pos = sizeof(uint16_t) + header.key_len;
        }

        if (header.value_len > 0) {
            deserialize_value(payload + pos, header.value_len, &value);
        }

        // Call callback
        callback((wal_op_type_t)header.op_type, key,
                 header.value_len > 0 ? &value : NULL,
                 header.timestamp, header.sequence, ctx);

        entry_count++;

        // Cleanup
        if (key) DB_FREE(key);
        value_free(&value);
        DB_FREE(payload);
    }

    close(fd);

    db_info("WAL recovery complete: %d entries, %d corrupt",
            entry_count, corrupt_count);

    return entry_count;
}

bool wal_validate(const char *filename) {
    // Implementation similar to recover but without callbacks
    // Returns true if file is readable and valid
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        return false;
    }
    close(fd);
    return true;
}

// ============================================================================
// STATISTICS
// ============================================================================

void wal_get_stats(wal_t *wal, wal_stats_t *stats) {
    if (!wal || !stats) return;
    memcpy(stats, &wal->stats, sizeof(wal_stats_t));
}

void wal_print_stats(wal_t *wal) {
    if (!wal) return;

    wal_stats_t stats;
    wal_get_stats(wal, &stats);

    db_info("WAL Statistics:");
    db_info("  Total entries: %lu", stats.total_entries);
    db_info("  SET operations: %lu", stats.set_ops);
    db_info("  DELETE operations: %lu", stats.delete_ops);
    db_info("  CLEAR operations: %lu", stats.clear_ops);
}
```

### 3. Integration with KV Store

Update src/kv_store.c to use WAL:

```c
#include "wal.h"

struct kv_store {
    hash_table_t *ht;
    wal_t *wal;
    bool recovery_mode;
};

kv_store_t *kv_store_create_with_wal(const char *wal_filename) {
    kv_store_t *store = DB_MALLOC(sizeof(kv_store_t));
    if (!store) {
        return NULL;
    }

    store->ht = ht_create(HT_INITIAL_CAPACITY);
    if (!store->ht) {
        DB_FREE(store);
        return NULL;
    }

    store->wal = NULL;
    store->recovery_mode = false;

    if (wal_filename) {
        store->wal = wal_open(wal_filename);
        if (!store->wal) {
            ht_destroy(store->ht);
            DB_FREE(store);
            return NULL;
        }
    }

    db_info("Key-value store created (WAL: %s)",
            wal_filename ? wal_filename : "disabled");
    return store;
}

db_error_t kv_store_set(kv_store_t *store, const char *key,
                        const value_t *value) {
    if (!store || !key || !value) {
        return DB_ERROR_INVALID;
    }

    // Write to WAL first (Write-Ahead!)
    if (store->wal && !store->recovery_mode) {
        db_error_t err = wal_log_set(store->wal, key, value);
        if (err != DB_OK) {
            return err;
        }
    }

    // Then update in-memory
    return ht_set(store->ht, key, value);
}

db_error_t kv_store_delete(kv_store_t *store, const char *key) {
    if (!store || !key) {
        return DB_ERROR_INVALID;
    }

    // Write to WAL first
    if (store->wal && !store->recovery_mode) {
        db_error_t err = wal_log_delete(store->wal, key);
        if (err != DB_OK) {
            return err;
        }
    }

    return ht_delete(store->ht, key);
}
```

## Code Walkthrough

### Binary Format

Each log entry consists of:

1. **Header (fixed size):** Magic, version, checksum, timestamp, sizes
2. **Payload (variable):** Key length, key data, value data

### Write-Ahead Protocol

1. Serialize operation to buffer
2. Calculate checksum
3. Write header + payload atomically
4. Sync to disk (fsync)
5. Apply to in-memory structure

### Recovery Process

1. Open WAL file
2. Read entries sequentially
3. Validate each entry (magic, checksum)
4. Apply valid operations to memory
5. Skip corrupt entries

## Hands-On Exercise

### Challenge: Test WAL Durability

**Goal:** Verify that data survives crashes

**Requirements:**

1. **Write a test program that:**
   - Opens database with WAL
   - Inserts 1000 entries
   - Crashes (use abort() or kill -9)
   - Reopens and verifies all data

2. **Test corruption handling:**
   - Corrupt a byte in the WAL file
   - Verify recovery skips corrupt entry
   - Verify subsequent entries are still recovered

3. **Measure performance:**
   - Time 10000 insertions with WAL
   - Time 10000 insertions without WAL
   - Calculate overhead percentage

**Expected Output:**

```
WAL Durability Test
===================
Inserted 1000 entries
Simulating crash...

Recovering...
Recovered 1000 entries
All data verified!

Performance:
  With WAL: 2.34s
  Without WAL: 0.12s
  Overhead: 95%
```

## Solution

<details>
<summary>Click to see test implementation</summary>

```c
void test_durability(void) {
    printf("WAL Durability Test\n");
    printf("===================\n");

    const char *wal_file = "test.wal";

    // Phase 1: Insert data
    {
        kv_store_t *store = kv_store_create_with_wal(wal_file);

        for (int i = 0; i < 1000; i++) {
            char key[32], value[32];
            snprintf(key, sizeof(key), "key_%d", i);
            snprintf(value, sizeof(value), "value_%d", i);

            value_t v = value_from_string(value);
            kv_store_set(store, key, &v);
            value_free(&v);
        }

        printf("Inserted 1000 entries\n");
        printf("Simulating crash...\n");

        // Don't close properly - simulate crash
        exit(0);  // Or use abort()
    }
}

void test_recovery(void) {
    printf("\nRecovering...\n");

    kv_store_t *store = kv_store_create_with_wal("test.wal");

    // Recovery happens automatically
    printf("Recovered %zu entries\n", kv_store_count(store));

    // Verify
    int verified = 0;
    for (int i = 0; i < 1000; i++) {
        char key[32], expected[32];
        snprintf(key, sizeof(key), "key_%d", i);
        snprintf(expected, sizeof(expected), "value_%d", i);

        const value_t *v = kv_store_get(store, key);
        if (v &\u0026 v->type == VALUE_TYPE_STRING &\u002;
            strcmp(v->data.string_val, expected) == 0) {
            verified++;
        }
    }

    printf("Verified %d entries\n", verified);
    kv_store_destroy(store);
}
```

</details>

## Next Steps

In the next step, you'll implement **recovery procedures**:

- Automatic recovery on startup
- Handling partial writes
- Checkpointing for faster recovery
- Truncating old log entries

Your database will be able to survive any crash!
