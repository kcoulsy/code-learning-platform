---
title: "Pointers and Arrays"
order: 4
---

# Pointers and Arrays

Arrays and pointers are deeply connected in C. In fact, array notation is just syntactic sugar for pointer arithmetic. Understanding this relationship is crucial for mastering C.

## The Array-Pointer Connection

When you declare an array, the array name acts like a pointer to the first element.

```c
#include <stdio.h>

int main(void) {
    int arr[] = {10, 20, 30, 40, 50};

    // Array name is a pointer to the first element
    printf("arr:       %p\n", (void*)arr);
    printf("&arr[0]:   %p\n", (void*)&arr[0]);

    // These are equivalent
    printf("arr[0] = %d\n", arr[0]);         // 10
    printf("*arr = %d\n", *arr);             // 10

    printf("arr[1] = %d\n", arr[1]);         // 20
    printf("*(arr + 1) = %d\n", *(arr + 1)); // 20

    printf("arr[4] = %d\n", arr[4]);         // 50
    printf("*(arr + 4) = %d\n", *(arr + 4)); // 50

    return 0;
}
```

**Key insight:** `arr[i]` is exactly the same as `*(arr + i)`!

## Array Indexing is Pointer Arithmetic

The `[]` operator is defined as pointer arithmetic plus dereference.

```c
#include <stdio.h>

int main(void) {
    int numbers[] = {100, 200, 300, 400, 500};

    // These four lines are IDENTICAL in behavior
    printf("%d\n", numbers[2]);      // Array indexing
    printf("%d\n", *(numbers + 2));  // Pointer arithmetic
    printf("%d\n", 2[numbers]);      // Weird but legal!
    printf("%d\n", *(2 + numbers));  // Same as above

    // Why does 2[numbers] work?
    // Because arr[i] is defined as *(arr + i)
    // And addition is commutative: arr + i = i + arr
    // So arr[i] = i[arr]
    // Don't use this in real code!

    return 0;
}
```

## Array Name vs. Pointer Variable

While array names act like pointers, they're not exactly the same as pointer variables.

```c
#include <stdio.h>

int main(void) {
    int arr[] = {10, 20, 30};
    int *ptr = arr;

    // This works: ptr is a variable
    ptr++;
    printf("ptr after ++: points to %d\n", *ptr);  // 20

    // This doesn't work: arr is not a variable
    // arr++;  // ERROR: can't modify array name

    // arr is a constant pointer (can't be reassigned)
    // ptr is a pointer variable (can be reassigned)

    // But both can be used with pointer arithmetic
    printf("arr[1] = %d\n", arr[1]);           // 20
    printf("*(arr + 1) = %d\n", *(arr + 1));   // 20

    return 0;
}
```

**Key difference:**
- Array name: constant pointer (can't modify it)
- Pointer variable: modifiable (can reassign or increment)

## Understanding Array Decay: A Mental Model

**Think of it like this:** Passing an array to a function is like giving someone the address of a storage facility, not moving all the furniture.

**Array Decay - The Vanishing Size Problem:**

When you pass an array to a function, it "decays" into a pointer. The array "shrinks" down to just its starting address, losing all information about its size.

**Visual representation:**
```
In main():
int arr[5] = {10, 20, 30, 40, 50};

Memory:  [10][20][30][40][50]
         ↑
         arr knows: address + size (5 elements)

Passing to function:
void func(int arr[]) {
    // arr is now just a pointer!
}

What function receives:
         ↑
         ptr knows: address only (size lost!)
```

**Key insight:** The brackets `[]` in function parameters are **syntactic sugar** - they look like an array but it's really a pointer. This is why:
- `sizeof(arr)` in the function gives pointer size (8 bytes), not array size (20 bytes)
- The function can't know how many elements there are
- You must always pass size separately

**This explains why:**
- You can modify the original array through the function (same memory, not a copy)
- Functions can't use `sizeof` to find array length
- These three declarations are identical:
  ```c
  void func(int arr[])     // Looks like array
  void func(int arr[100])  // Size ignored!
  void func(int *arr)      // Reality: it's a pointer
  ```

**The "vanishing size" problem:**
```c
int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printf("In main: sizeof(arr) = %zu\n", sizeof(arr));  // 20 bytes (5 * 4)
    func(arr);
}

void func(int arr[]) {
    printf("In func: sizeof(arr) = %zu\n", sizeof(arr));  // 8 bytes (pointer!)
    // The size information vanished when array decayed to pointer!
}
```

**Prevention:** Always pass size as a separate parameter:
```c
void func(int arr[], int size) {  // Now function knows the size
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}
```

## Arrays as Function Parameters

When you pass an array to a function, it **decays** to a pointer. The function receives a pointer, not a copy of the array.

```c
#include <stdio.h>

// These three declarations are IDENTICAL
void print_array1(int arr[], int size);
void print_array2(int *arr, int size);
void print_array3(int arr[10], int size);  // Size is ignored!

void print_array1(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

void modify_array(int arr[], int size) {
    // Modifying through the pointer affects the original array
    for (int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

int main(void) {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);

    printf("Original: ");
    print_array1(numbers, size);

    modify_array(numbers, size);

    printf("Modified: ");
    print_array1(numbers, size);

    // sizeof behaves differently
    printf("In main, sizeof(numbers) = %zu\n", sizeof(numbers));      // 20 (5 * 4)

    return 0;
}

// If we try sizeof inside print_array1:
void print_size(int arr[]) {
    printf("In function, sizeof(arr) = %zu\n", sizeof(arr));  // 8 (pointer size)
    // This is the size of a POINTER, not the array!
}
```

**Important:**
- Arrays passed to functions become pointers
- `sizeof` on array in function gives pointer size, not array size
- Always pass the size as a separate parameter
- Changes through the pointer affect the original array

## Multidimensional Arrays

Arrays can have multiple dimensions, but they're still stored in contiguous memory.

```c
#include <stdio.h>

int main(void) {
    int matrix[3][4] = {
        {1,  2,  3,  4},
        {5,  6,  7,  8},
        {9, 10, 11, 12}
    };

    // Access with array notation
    printf("matrix[1][2] = %d\n", matrix[1][2]);  // 7

    // Access with pointer notation
    // matrix[i][j] = *(*(matrix + i) + j)
    printf("*(*(matrix + 1) + 2) = %d\n", *(*(matrix + 1) + 2));  // 7

    // Flatten to single array (row-major order)
    int *flat = (int*)matrix;
    printf("Accessing as flat array:\n");
    for (int i = 0; i < 12; i++) {
        printf("%d ", flat[i]);
    }
    printf("\n");

    return 0;
}
```

## String Literals and Character Arrays

Strings are just arrays of characters, so pointers work with them too.

```c
#include <stdio.h>

int main(void) {
    // Character array: modifiable
    char str1[] = "Hello";
    str1[0] = 'h';  // OK: you can modify
    printf("%s\n", str1);  // "hello"

    // String literal: read-only
    char *str2 = "World";
    // str2[0] = 'w';  // CRASH! String literals are read-only

    // Both can be traversed with pointers
    char *p = str1;
    while (*p != '\0') {
        printf("%c", *p);
        p++;
    }
    printf("\n");

    return 0;
}
```

**Key difference:**
- `char arr[] = "..."`: Creates modifiable array
- `char *str = "..."`: Points to read-only string literal (better: `const char *str`)

## Pointer to Array vs. Array of Pointers

These are completely different types!

```c
#include <stdio.h>

int main(void) {
    int arr[5] = {10, 20, 30, 40, 50};

    // Pointer to an array of 5 ints
    int (*ptr_to_array)[5] = &arr;
    printf("First element via ptr_to_array: %d\n", (*ptr_to_array)[0]);  // 10

    // Array of 3 pointers to int
    int a = 1, b = 2, c = 3;
    int *array_of_ptrs[3] = {&a, &b, &c};
    printf("Via array_of_ptrs: %d, %d, %d\n",
           *array_of_ptrs[0], *array_of_ptrs[1], *array_of_ptrs[2]);  // 1, 2, 3

    // Key difference:
    // int (*p)[5]  - p is a pointer to an array of 5 ints
    // int *p[5]    - p is an array of 5 pointers to int

    return 0;
}
```

**Read declarations right-to-left:**
- `int (*p)[5]`: `p` is a pointer to an array of 5 ints
- `int *p[5]`: `p` is an array of 5 pointers to int

## Why This Matters

Understanding the array-pointer relationship is fundamental to C mastery:

**1. Efficient Function Calls**
Arrays aren't copied when passed to functions - only the address is passed:
```c
void process(int arr[], int size) {  // Fast: passes pointer (8 bytes)
    arr[0] = 100;  // Modifies original array
}
// vs copying entire array (slow for large arrays!)
```

**2. String Manipulation**
All string operations in C rely on char pointers:
```c
char *strcpy(char *dest, const char *src);  // Pointers, not arrays
char *strcat(char *dest, const char *src);
int strcmp(const char *s1, const char *s2);
```

**3. Dynamic Arrays**
Runtime-sized arrays require pointers:
```c
int size = get_user_input();
int *arr = malloc(size * sizeof(int));  // Pointer to dynamic array
// Can't do: int arr[size] in all C versions
```

**4. Data Structures**
Linked lists, trees, graphs all use arrays of pointers:
```c
struct Node *children[10];  // Array of 10 pointers
char *argv[];               // Array of string pointers (command-line args)
```

**5. Performance Optimization**
Pointer arithmetic is often faster than array indexing:
```c
// Compiler can optimize pointer version better
for (char *p = str; *p; p++) {  // Pointer style
    process(*p);
}
```

**What breaks if you misunderstand arrays/pointers:**
- **sizeof bugs** - Using `sizeof(arr)` in functions gives wrong size
- **String errors** - Thinking `char *` and `char[]` are identical (they're not)
- **Memory leaks** - Not freeing dynamic arrays
- **Buffer overflows** - Not tracking array size properly
- **Segfaults** - Modifying string literals through `char *`

**In real code:**
- **Command-line parsing**: `int main(int argc, char *argv[])`
- **String libraries**: All use `char *`, not `char[]`
- **Image processing**: Walk through pixel arrays with pointers
- **Network protocols**: Parse packet buffers with pointer arithmetic
- **Operating systems**: System calls use pointer-to-array patterns

**Professional practice:**
- Always pass array size to functions
- Use `const` for read-only arrays: `void func(const int arr[], int size)`
- Prefer `char arr[]` for modifiable strings, `const char *` for literals
- Document whether your function allocates memory (caller must free)
- Be explicit: `int arr[100]` in main, `int *arr` in parameters

## Common Pitfalls

### Pitfall 1: Confusing Array Name with Pointer Variable

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;

ptr++;      // OK: ptr is a variable
// arr++;   // ERROR: arr is not a variable
```

**Fix:** Remember array names are constant pointers.

### Pitfall 2: sizeof on Array Parameter (The Decay Bug)

**Why it happens:** Array parameters decay to pointers, so `sizeof` returns pointer size, not array size.

```c
void process(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // WRONG!
    // sizeof(arr) = 8 (pointer size on 64-bit)
    // sizeof(arr[0]) = 4 (int size)
    // Result: 8/4 = 2 (NOT the actual array size!)

    printf("Function thinks array has %d elements\n", size);  // Prints: 2
}

int main() {
    int numbers[100];  // Actually has 100 elements
    printf("Main knows array has %d elements\n",
           (int)(sizeof(numbers)/sizeof(numbers[0])));  // Prints: 100

    process(numbers);  // Function loses size information
    return 0;
}
```

**What you'll see:**
```
Main knows array has 100 elements
Function thinks array has 2 elements
```

**Why this is dangerous:**
```c
void dangerous(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // Gets 2 instead of real size
    for (int i = 0; i < size; i++) {          // Only processes 2 elements!
        arr[i] = 0;  // Rest of array unchanged
    }
}
```

**The fix - Always pass size:**
```c
void correct(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = 0;
    }
}

int main() {
    int numbers[100];
    int size = sizeof(numbers) / sizeof(numbers[0]);  // Calculate in main
    correct(numbers, size);  // Pass explicitly
    return 0;
}
```

**Alternative - Use pointer notation to make it obvious:**
```c
void process(int *arr, int size) {  // Pointer notation - no confusion
    // Everyone knows arr is just a pointer
}
```

**Prevention:**
- Calculate size in main with `sizeof`, pass as parameter
- Use pointer notation `int *arr` instead of `int arr[]` in parameters (more honest)
- Compiler warning: `gcc -Wsizeof-array-argument` (warns about this pattern)
- Better yet: use a struct that includes size:
```c
typedef struct {
    int *data;
    size_t size;
} IntArray;
```

### Pitfall 3: Returning Local Array

```c
int* create_array(void) {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // DANGER! arr goes out of scope
}

int main(void) {
    int *ptr = create_array();
    printf("%d\n", ptr[0]);  // Undefined behavior!
}
```

**Fix:** Use dynamic allocation (next lesson) or pass array as parameter.

### Pitfall 4: String Literal Modification

```c
char *str = "Hello";
str[0] = 'h';  // CRASH! String literals are read-only
```

**Fix:** Use `char arr[] = "Hello";` or `const char *str = "Hello";`

### Pitfall 5: Pointer Arithmetic Beyond Array Bounds

```c
int arr[3] = {1, 2, 3};
int *ptr = arr;
ptr += 10;           // ptr now points outside the array
printf("%d\n", *ptr); // Undefined behavior!
```

**Fix:** Always keep pointers within array bounds (plus one past the end for comparisons).

### Pitfall 6: Comparing Array Name with NULL

```c
int arr[5];
if (arr == NULL) {  // Always false! arr is not a pointer variable
    printf("NULL\n");
}
```

**Fix:** Array names can't be NULL. Only pointer variables can be NULL.

### Pitfall 7: Multidimensional Array Access

```c
int matrix[3][4];
int *ptr = matrix;  // WARNING: type mismatch
                    // matrix is int(*)[4], not int*

// Correct:
int (*ptr)[4] = matrix;
```

**Fix:** Match pointer type to array type, or use int* with manual calculation.

## Array vs. Pointer Summary

| Feature | Array Name | Pointer Variable |
|---------|-----------|------------------|
| Stores address | Yes | Yes |
| Can be modified | No | Yes |
| `sizeof` result | Array size | Pointer size |
| Can be NULL | No | Yes |
| Arithmetic | Yes | Yes |
| Dereferencing | Yes | Yes |

## Key Takeaways

- Array name acts like a constant pointer to the first element
- `arr[i]` is exactly `*(arr + i)`
- Array names can't be modified (no `arr++`)
- Arrays passed to functions decay to pointers
- Always pass array size as a separate parameter
- `sizeof` on array parameter gives pointer size, not array size
- String literals are read-only (use `const char*`)
- `char arr[] = "..."` creates modifiable array
- `char *str = "..."` points to read-only literal
- Keep pointers within array bounds

## Exercises

1. **Pointer vs. Index**: Write two versions of a function that finds the maximum element in an array: one using array indexing `[]`, one using only pointer arithmetic. Verify they produce identical results.

2. **Array Reversal**: Write a function that reverses an array in place using two pointers: one at the start, one at the end. Don't use array indexing.

3. **String Length**: Implement your own `strlen` function using pointer arithmetic. Count characters until you hit `'\0'`.

4. **2D Array Access**: Create a 3x3 matrix and write code to access element `[1][2]` using:
   - Array notation: `matrix[1][2]`
   - Pointer notation: `*(*(matrix + 1) + 2)`
   - Flattened pointer: `*((int*)matrix + 1*3 + 2)`

5. **Array Decay Demo**: Write a function that prints `sizeof` the parameter. Call it with an array. Compare with `sizeof` in main. Explain the difference.

6. **Safe String Copy**: Write a function `safe_strcpy` that copies a string using pointers. Include a maximum length parameter to prevent buffer overflow.

7. **Array of Strings**: Create an array of string pointers: `char *days[] = {"Mon", "Tue", "Wed"};`. Print all strings using pointer arithmetic.
