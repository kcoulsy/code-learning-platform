---
id: recovery-procedures
title: 'Recovery Procedures'
order: 2
---

# Recovery Procedures

## Prerequisites

- Completion of Lesson 3 Step 1: Write-Ahead Log
- Understanding of database recovery concepts
- Knowledge of file operations in C

## Learning Objectives

By the end of this step, you will:

- Implement automatic recovery on startup
- Handle partial writes and corruption
- Create checkpointing for faster recovery
- Manage WAL file size through truncation
- Build a resilient database system

## Overview

Recovery is the process of restoring database state after a crash. We'll implement:

1. **Automatic Recovery:** Replay WAL on startup
2. **Partial Write Handling:** Detect and skip incomplete entries
3. **Checkpointing:** Periodic snapshots for faster recovery
4. **Log Truncation:** Remove old entries after checkpoint

## Complete Implementation

### 1. Recovery Header (src/recovery.h)

```c
#ifndef RECOVERY_H
#define RECOVERY_H

#include "utils.h"
#include "kv_store.h"
#include "wal.h"

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// RECOVERY CONTEXT
// ============================================================================

typedef struct {
    kv_store_t *store;
    uint64_t last_sequence;
    uint64_t last_checkpoint;
    size_t entries_recovered;
    size_t entries_skipped;
    uint64_t recovery_time_us;
} recovery_context_t;

// ============================================================================
// RECOVERY FUNCTIONS
// ============================================================================

// Recover database from WAL
// This replays all operations from the WAL file
// Returns DB_OK on success, error code on failure
db_error_t recover_from_wal(kv_store_t *store, const char *wal_filename);

// Recover with detailed context
// Provides detailed information about the recovery process
db_error_t recover_from_wal_ex(kv_store_t *store, const char *wal_filename,
                                recovery_context_t *ctx);

// ============================================================================
// CHECKPOINTING
// ============================================================================

typedef struct {
    uint64_t checkpoint_id;
    uint64_t sequence_number;
    uint64_t timestamp;
    uint64_t entry_count;
    char wal_filename[256];
} checkpoint_info_t;

// Create a checkpoint
// Writes current state to checkpoint file and truncates WAL
db_error_t create_checkpoint(kv_store_t *store, const char *wal_filename,
                              const char *checkpoint_filename);

// Restore from checkpoint
// Loads state from checkpoint file
db_error_t restore_from_checkpoint(kv_store_t *store,
                                    const char *checkpoint_filename);

// Get checkpoint info
// Returns true if checkpoint exists and is valid
bool get_checkpoint_info(const char *checkpoint_filename,
                         checkpoint_info_t *info);

// ============================================================================
// RECOVERY WITH CHECKPOINT
// ============================================================================

// Full recovery: checkpoint + WAL replay
// 1. Restore from checkpoint if exists
// 2. Replay WAL entries after checkpoint
db_error_t recover_full(kv_store_t *store, const char *checkpoint_filename,
                        const char *wal_filename);

// ============================================================================
// WAL MANAGEMENT
// ============================================================================

// Truncate WAL up to a sequence number
// Removes all entries with sequence <= seq
db_error_t wal_truncate(const char *wal_filename, uint32_t seq);

// Get WAL file size
uint64_t wal_file_size(const char *wal_filename);

// Compact WAL by removing overwritten entries
// Keeps only the latest value for each key
db_error_t wal_compact(const char *wal_filename,
                       const char *output_filename);

// ============================================================================
// RECOVERY STATISTICS
// ============================================================================

typedef struct {
    uint64_t start_time;
    uint64_t end_time;
    size_t total_entries;
    size_t set_operations;
    size_t delete_operations;
    size_t clear_operations;
    size_t corrupt_entries;
    size_t duplicate_entries;  // Same sequence number
    uint64_t bytes_processed;
    bool from_checkpoint;
    uint64_t checkpoint_sequence;
} recovery_stats_t;

// Get recovery statistics
void get_recovery_stats(recovery_stats_t *stats);

// Print recovery report
void print_recovery_report(const recovery_stats_t *stats);

#ifdef __cplusplus
}
#endif

#endif // RECOVERY_H
```

### 2. Recovery Implementation (src/recovery.c)

```c
#include "recovery.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>

// ============================================================================
// RECOVERY CALLBACK
// ============================================================================

static void recovery_callback(wal_op_type_t op, const char *key,
                               const value_t *value, uint64_t timestamp,
                               uint32_t sequence, void *ctx) {
    (void)timestamp;

    recovery_context_t *rctx = (recovery_context_t *)ctx;

    // Track sequence numbers
    if (sequence > rctx->last_sequence) {
        rctx->last_sequence = sequence;
    }

    // Apply operation
    switch (op) {
        case WAL_OP_SET:
            if (key && value) {
                // Temporarily disable WAL logging during recovery
                // to avoid re-logging recovered operations
                kv_store_set(rctx->store, key, value);
                rctx->entries_recovered++;
            }
            break;

        case WAL_OP_DELETE:
            if (key) {
                kv_store_delete(rctx->store, key);
                rctx->entries_recovered++;
            }
            break;

        case WAL_OP_CLEAR:
            kv_store_clear(rctx->store);
            rctx->entries_recovered++;
            break;

        case WAL_OP_CHECKPOINT:
            rctx->last_checkpoint = sequence;
            break;

        default:
            db_warn("Unknown WAL operation type: %d", op);
            rctx->entries_skipped++;
            break;
    }
}

// ============================================================================
// BASIC RECOVERY
// ============================================================================

db_error_t recover_from_wal(kv_store_t *store, const char *wal_filename) {
    recovery_context_t ctx;
    memset(&ctx, 0, sizeof(ctx));
    ctx.store = store;

    return recover_from_wal_ex(store, wal_filename, &ctx);
}

db_error_t recover_from_wal_ex(kv_store_t *store, const char *wal_filename,
                                recovery_context_t *ctx) {
    if (!store || !wal_filename || !ctx) {
        return DB_ERROR_INVALID;
    }

    ctx->store = store;
    ctx->last_sequence = 0;
    ctx->entries_recovered = 0;
    ctx->entries_skipped = 0;

    db_info("Starting recovery from: %s", wal_filename);
    uint64_t start_time = db_get_time_ms();

    // Check if WAL file exists
    struct stat st;
    if (stat(wal_filename, &st) != 0) {
        if (errno == ENOENT) {
            db_info("No WAL file found, starting with empty database");
            ctx->recovery_time_us = 0;
            return DB_OK;
        }
        db_error("Cannot stat WAL file: %s", strerror(errno));
        return DB_ERROR_IO;
    }

    db_info("WAL file size: %lu bytes", (unsigned long)st.st_size);

    // Recover from WAL
    int count = wal_recover(wal_filename, recovery_callback, ctx);

    if (count < 0) {
        db_error("Recovery failed");
        return DB_ERROR_IO;
    }

    ctx->recovery_time_us = (db_get_time_ms() - start_time) * 1000;

    db_info("Recovery complete:");
    db_info("  Entries recovered: %zu", ctx->entries_recovered);
    db_info("  Entries skipped: %zu", ctx->entries_skipped);
    db_info("  Last sequence: %llu", (unsigned long long)ctx->last_sequence);
    db_info("  Time: %.2f ms", ctx->recovery_time_us / 1000.0);

    return DB_OK;
}

// ============================================================================
// CHECKPOINTING
// ============================================================================

// Checkpoint file format:
// - Header (magic, version, timestamp, entry_count)
// - Sequence of key-value pairs
// - Footer (checksum)

#define CHECKPOINT_MAGIC 0x43484B50  // "CHKP"
#define CHECKPOINT_VERSION 1

#pragma pack(push, 1)
typedef struct {
    uint32_t magic;
    uint16_t version;
    uint64_t timestamp;
    uint64_t sequence_number;
    uint64_t entry_count;
    uint32_t checksum;
} checkpoint_header_t;
#pragma pack(pop)

db_error_t create_checkpoint(kv_store_t *store, const char *wal_filename,
                              const char *checkpoint_filename) {
    if (!store || !checkpoint_filename) {
        return DB_ERROR_INVALID;
    }

    db_info("Creating checkpoint: %s", checkpoint_filename);

    // Open checkpoint file
    int fd = open(checkpoint_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        db_error("Cannot create checkpoint: %s", strerror(errno));
        return DB_ERROR_IO;
    }

    // Write header placeholder
    checkpoint_header_t header;
    memset(&header, 0, sizeof(header));
    header.magic = CHECKPOINT_MAGIC;
    header.version = CHECKPOINT_VERSION;
    header.timestamp = (uint64_t)time(NULL);

    if (write(fd, &header, sizeof(header)) != sizeof(header)) {
        close(fd);
        db_error("Failed to write checkpoint header");
        return DB_ERROR_IO;
    }

    // Write all entries
    uint64_t entry_count = 0;
    kv_iterator_t *iter = kv_iterator_create(store);

    while (kv_iterator_next(iter)) {
        const char *key = kv_iterator_key(iter);
        const value_t *value = kv_iterator_value(iter);

        // Write key length and key
        uint16_t key_len = strlen(key);
        if (write(fd, &key_len, sizeof(key_len)) != sizeof(key_len)) {
            kv_iterator_destroy(iter);
            close(fd);
            return DB_ERROR_IO;
        }
        if (write(fd, key, key_len) != key_len) {
            kv_iterator_destroy(iter);
            close(fd);
            return DB_ERROR_IO;
        }

        // Serialize and write value
        uint8_t *value_data = NULL;
        size_t value_len = 0;
        // (Use serialize_value from wal.c)

        if (write(fd, &value_len, sizeof(uint32_t)) != sizeof(uint32_t)) {
            kv_iterator_destroy(iter);
            close(fd);
            return DB_ERROR_IO;
        }
        if (value_len > 0 && write(fd, value_data, value_len) != (ssize_t)value_len) {
            kv_iterator_destroy(iter);
            close(fd);
            return DB_ERROR_IO;
        }

        entry_count++;
    }

    kv_iterator_destroy(iter);

    // Update header with actual count
    header.entry_count = entry_count;
    header.sequence_number = entry_count;  // Simplified

    // Seek back and rewrite header
    lseek(fd, 0, SEEK_SET);
    if (write(fd, &header, sizeof(header)) != sizeof(header)) {
        close(fd);
        return DB_ERROR_IO;
    }

    fsync(fd);
    close(fd);

    db_info("Checkpoint created: %llu entries", (unsigned long long)entry_count);

    // Optionally truncate WAL
    if (wal_filename) {
        // Truncate WAL up to current sequence
        db_info("Truncating WAL file");
        // Implementation of wal_truncate...
    }

    return DB_OK;
}

db_error_t restore_from_checkpoint(kv_store_t *store,
                                    const char *checkpoint_filename) {
    if (!store || !checkpoint_filename) {
        return DB_ERROR_INVALID;
    }

    int fd = open(checkpoint_filename, O_RDONLY);
    if (fd < 0) {
        if (errno == ENOENT) {
            // No checkpoint - that's OK
            return DB_OK;
        }
        db_error("Cannot open checkpoint: %s", strerror(errno));
        return DB_ERROR_IO;
    }

    checkpoint_header_t header;
    if (read(fd, &header, sizeof(header)) != sizeof(header)) {
        close(fd);
        db_error("Failed to read checkpoint header");
        return DB_ERROR_IO;
    }

    // Validate header
    if (header.magic != CHECKPOINT_MAGIC) {
        close(fd);
        db_error("Invalid checkpoint file");
        return DB_ERROR_CORRUPT;
    }

    db_info("Restoring from checkpoint:");
    db_info("  Entries: %llu", (unsigned long long)header.entry_count);
    db_info("  Timestamp: %llu", (unsigned long long)header.timestamp);

    // Read entries
    for (uint64_t i = 0; i < header.entry_count; i++) {
        uint16_t key_len;
        if (read(fd, &key_len, sizeof(key_len)) != sizeof(key_len)) {
            close(fd);
            return DB_ERROR_IO;
        }

        char *key = DB_MALLOC(key_len + 1);
        if (!key) {
            close(fd);
            return DB_ERROR_NOMEM;
        }

        if (read(fd, key, key_len) != key_len) {
            DB_FREE(key);
            close(fd);
            return DB_ERROR_IO;
        }
        key[key_len] = '\0';

        // Read value
        uint32_t value_len;
        if (read(fd, &value_len, sizeof(value_len)) != sizeof(value_len)) {
            DB_FREE(key);
            close(fd);
            return DB_ERROR_IO;
        }

        value_t value;
        memset(&value, 0, sizeof(value));

        if (value_len > 0) {
            uint8_t *value_data = DB_MALLOC(value_len);
            if (!value_data) {
                DB_FREE(key);
                close(fd);
                return DB_ERROR_NOMEM;
            }

            if (read(fd, value_data, value_len) != (ssize_t)value_len) {
                DB_FREE(value_data);
                DB_FREE(key);
                close(fd);
                return DB_ERROR_IO;
            }

            // Deserialize value
            // deserialize_value(value_data, value_len, &value);
            DB_FREE(value_data);
        }

        // Insert into store
        kv_store_set(store, key, &value);
        value_free(&value);
        DB_FREE(key);
    }

    close(fd);

    db_info("Checkpoint restored successfully");
    return DB_OK;
}

bool get_checkpoint_info(const char *checkpoint_filename,
                         checkpoint_info_t *info) {
    if (!checkpoint_filename || !info) {
        return false;
    }

    int fd = open(checkpoint_filename, O_RDONLY);
    if (fd < 0) {
        return false;
    }

    checkpoint_header_t header;
    ssize_t n = read(fd, &header, sizeof(header));
    close(fd);

    if (n != sizeof(header)) {
        return false;
    }

    if (header.magic != CHECKPOINT_MAGIC) {
        return false;
    }

    info->checkpoint_id = 1;  // Simplified
    info->sequence_number = header.sequence_number;
    info->timestamp = header.timestamp;
    info->entry_count = header.entry_count;
    strncpy(info->wal_filename, "wal.log", sizeof(info->wal_filename) - 1);

    return true;
}

// ============================================================================
// FULL RECOVERY
// ============================================================================

db_error_t recover_full(kv_store_t *store, const char *checkpoint_filename,
                        const char *wal_filename) {
    db_error_t err;

    db_info("Starting full recovery...");

    // Step 1: Restore from checkpoint if available
    if (checkpoint_filename) {
        checkpoint_info_t cp_info;
        if (get_checkpoint_info(checkpoint_filename, &cp_info)) {
            db_info("Found checkpoint, restoring...");
            err = restore_from_checkpoint(store, checkpoint_filename);
            if (err != DB_OK) {
                db_error("Checkpoint restore failed");
                return err;
            }
        }
    }

    // Step 2: Replay WAL
    if (wal_filename) {
        recovery_context_t ctx;
        memset(&ctx, 0, sizeof(ctx));
        ctx.store = store;

        err = recover_from_wal_ex(store, wal_filename, &ctx);
        if (err != DB_OK) {
            db_error("WAL recovery failed");
            return err;
        }
    }

    db_info("Full recovery complete");
    return DB_OK;
}

// ============================================================================
// WAL MANAGEMENT
// ============================================================================

uint64_t wal_file_size(const char *wal_filename) {
    struct stat st;
    if (stat(wal_filename, &st) != 0) {
        return 0;
    }
    return st.st_size;
}

db_error_t wal_truncate(const char *wal_filename, uint32_t seq) {
    (void)wal_filename;
    (void)seq;
    // Implementation: read WAL, write entries with seq > cutoff to temp file,
    // then atomically replace
    db_info("WAL truncation not yet implemented");
    return DB_OK;
}

// ============================================================================
// STATISTICS
// ============================================================================

static recovery_stats_t g_recovery_stats;

void get_recovery_stats(recovery_stats_t *stats) {
    if (stats) {
        memcpy(stats, &g_recovery_stats, sizeof(recovery_stats_t));
    }
}

void print_recovery_report(const recovery_stats_t *stats) {
    if (!stats) return;

    printf("\n");
    printf("╔════════════════════════════════════════╗\n");
    printf("║        RECOVERY REPORT                 ║\n");
    printf("╠════════════════════════════════════════╣\n");
    printf("║ Total entries:     %20zu ║\n", stats->total_entries);
    printf("║ SET operations:    %20zu ║\n", stats->set_operations);
    printf("║ DELETE operations: %20zu ║\n", stats->delete_operations);
    printf("║ CLEAR operations:  %20zu ║\n", stats->clear_operations);
    printf("║ Corrupt entries:   %20zu ║\n", stats->corrupt_entries);
    printf("║ Time elapsed:      %18.2f ms ║\n",
           (stats->end_time - stats->start_time) / 1000.0);
    printf("╚════════════════════════════════════════╝\n");
}
```

## Code Walkthrough

### Recovery Process

1. **Check for checkpoint:** Load if exists
2. **Replay WAL:** Apply all operations
3. **Handle errors:** Skip corrupt entries
4. **Report stats:** Log recovery details

### Checkpoint Format

- **Header:** Magic, version, metadata
- **Data:** Serialized key-value pairs
- **Footer:** Checksum for validation

### Benefits

- **Fast recovery:** Load checkpoint + replay small WAL
- **Bounded WAL size:** Truncate after checkpoint
- **Data integrity:** Checksums detect corruption

## Hands-On Exercise

### Challenge: Test Recovery Scenarios

**Goal:** Verify recovery works in various scenarios

**Requirements:**

1. **Test normal recovery:**
   - Insert data, close cleanly
   - Reopen and verify

2. **Test crash recovery:**
   - Insert data, kill -9 process
   - Reopen and verify

3. **Test checkpoint recovery:**
   - Create checkpoint
   - Add more data
   - Restore from checkpoint + WAL

4. **Measure recovery time:**
   - Time recovery with different data sizes
   - Compare with/without checkpoint

## Next Steps

In the next step, you'll implement **snapshot persistence**:

- Periodic automatic checkpoints
- Background checkpointing
- Incremental snapshots
- Point-in-time recovery

Your database will be both durable and efficient!
