---
title: 'Shell Design and Architecture'
order: 2
---

# Shell Design and Architecture

## Introduction

Now it's time to design your shell's architecture. A well-designed shell is modular, maintainable, and extensible. In this step, we'll break down the shell into components and plan the data structures and flow.

Before writing any code, understanding the architecture will save you countless hours of refactoring later.

## High-Level Architecture

A shell operates in a classic **REPL** (Read-Eval-Print Loop):

```
┌─────────────────────────────────────┐
│                                     │
│  ┌──────┐   ┌──────┐   ┌────────┐  │
│  │      │   │      │   │        │  │
│  │ READ │──▶│ EVAL │──▶│ PRINT  │  │
│  │      │   │      │   │        │  │
│  └──────┘   └──────┘   └────────┘  │
│      ▲                       │      │
│      │                       │      │
│      └───────────────────────┘      │
│                                     │
└─────────────────────────────────────┘
```

### The Three Phases

**1. READ** - Get input from the user

- Display prompt
- Read line with `readline()` or `fgets()`
- Handle EOF (Ctrl+D)

**2. EVAL** - Parse and execute the command

- Tokenize input into words
- Parse into command structure
- Check for built-ins
- Execute external programs
- Handle I/O redirection and pipes

**3. PRINT** - Display results

- Show command output (from executed programs)
- Display error messages
- Update prompt

## Core Components

### Component 1: Command Parser

**Purpose**: Convert raw input string into structured command representation

**Input**: `"ls -la | grep test > output.txt"`

**Output**: Structured command data

**Challenges**:

- Splitting by whitespace while respecting quotes
- Identifying special characters (`|`, `>`, `<`, `&`, `>>`)
- Handling escaped characters
- Managing memory for parsed data

**Design Questions**:

- How will you represent a command?
- How will you store arguments?
- How will you handle pipelines (multiple commands)?

### Component 2: Built-in Commands

**Purpose**: Handle commands that must run in the shell process itself

**Required Built-ins**:

- `cd <directory>` - Change directory
- `exit [code]` - Exit shell
- `export VAR=value` - Set environment variable
- `unset VAR` - Remove environment variable

**Why Built-ins?**:
Some commands can't be external programs:

- `cd` must change the shell's own working directory
- `exit` must terminate the shell process
- `export` must modify the shell's environment

**Design Questions**:

- How will you distinguish built-ins from external commands?
- How will you implement each built-in?
- How will built-ins interact with I/O redirection?

### Component 3: Process Executor

**Purpose**: Launch and manage external programs

**Key System Calls**:

```c
pid_t fork(void);           // Create child process
int execvp(const char *file, char *const argv[]);  // Execute program
pid_t waitpid(pid_t pid, int *status, int options); // Wait for child
```

**Process Flow**:

```
Parent Process (Shell)
    |
    | fork()
    |
    ├─────────────┬─────────────┐
    │             │             │
    │ (Parent)    │ (Child)     │
    │ waitpid()   │ execvp()    │
    │             │             │
    │             │ [Program    │
    │             │  Runs]      │
    │             │             │
    │             ▼             │
    │        exit/return        │
    │                           │
    └────────▶ [Continue]       │
```

**Design Questions**:

- How will you handle fork failures?
- What if exec fails?
- How will you capture exit status?

### Component 4: I/O Redirection

**Purpose**: Redirect stdin/stdout/stderr to files

**Operators**:

- `<` - Input from file
- `>` - Output to file (overwrite)
- `>>` - Output to file (append)
- `2>` - Error output to file

**Example**: `cat < input.txt > output.txt`

**Implementation Strategy**:

1. Parse redirection operators and filenames
2. In child process (before exec):
   - Open files with appropriate flags
   - Use `dup2()` to redirect file descriptors
   - Close original file descriptors
3. Execute command normally

**Key System Call**:

```c
int dup2(int oldfd, int newfd);
// Makes newfd be a copy of oldfd
```

**Design Questions**:

- Where in your command structure will you store redirection info?
- How will you handle multiple redirections?
- What about permission errors when opening files?

### Component 5: Pipelines

**Purpose**: Connect output of one command to input of another

**Example**: `ls -la | grep test | wc -l`

**Implementation Strategy**:

```c
int pipe(int pipefd[2]);
// pipefd[0] is read end
// pipefd[1] is write end
```

**Pipeline Flow**:

```
Command 1          Command 2          Command 3
    |                  |                  |
 stdout ─┐          stdin ─┐          stdin
         │                 │
     [pipe 1]          [pipe 2]
         │                 │
    ─────┴──── stdout ─────┴──── stdout
```

**Process Creation for Pipeline**:

1. Create all pipes
2. Fork for each command
3. In each child:
   - Redirect stdin from previous pipe (if not first)
   - Redirect stdout to next pipe (if not last)
   - Close unused pipe ends
   - Execute command
4. In parent: close all pipes, wait for all children

**Design Questions**:

- How will you represent a pipeline in your data structure?
- How will you manage multiple pipe file descriptors?
- What order should you close pipes?

### Component 6: Signal Handling

**Purpose**: Handle Ctrl+C and other signals gracefully

**Important Signals**:

- `SIGINT` - Ctrl+C (interrupt)
- `SIGTSTP` - Ctrl+Z (suspend)
- `SIGCHLD` - Child process terminated

**Behavior**:

- Ctrl+C should kill foreground process, not shell
- Shell should reap zombie processes
- Background processes shouldn't receive keyboard signals

**Implementation Hints**:

```c
#include <signal.h>

void handle_sigint(int sig) {
    // Handle Ctrl+C
}

signal(SIGINT, handle_sigint);
// or
struct sigaction sa;
sa.sa_handler = handle_sigint;
sigaction(SIGINT, &sa, NULL);
```

**Design Questions**:

- How will you prevent shell from exiting on Ctrl+C?
- How will you track the foreground process?
- How will you reap background processes?

## Data Structure Design

### Representing a Command

Consider this command:

```
ls -la /tmp | grep test > output.txt &
```

You need to capture:

- Command name: `ls`
- Arguments: `["-la", "/tmp"]`
- Input redirection: none
- Output redirection: none (pipe takes stdout)
- Next command in pipeline: `grep test`
- Background: no (only last command in pipeline)

### Suggested Structure

```c
#define MAX_ARGS 64
#define MAX_PATH 256

// Represents a single command in a pipeline
typedef struct Command {
    char *name;                      // Command name
    char *args[MAX_ARGS];            // NULL-terminated argument array
    char *input_file;                // NULL if no redirection
    char *output_file;               // NULL if no redirection
    int append;                      // 1 if >>, 0 if >
    struct Command *next;            // Next command in pipeline
} Command;

// Represents an entire command line
typedef struct CommandLine {
    Command *commands;               // Linked list of commands
    int background;                  // 1 if ends with &
} CommandLine
```

**Alternative**: Use arrays instead of linked lists

```c
typedef struct CommandLine {
    Command commands[MAX_PIPELINE];
    int num_commands;
    int background;
} CommandLine;
```

### Memory Management Strategy

**Option 1: Allocate during parsing, free after execution**

```c
CommandLine *parse(char *input);
execute(CommandLine *cmdline);
free_cmdline(cmdline);
```

**Option 2: Use static buffers (simpler but less flexible)**

```c
static CommandLine cmdline;
parse(char *input, &cmdline);
execute(&cmdline);
```

## Module Organization

### Recommended File Structure

```
shell/
├── Makefile
├── src/
│   ├── main.c           # Main REPL loop
│   ├── parser.c         # Tokenizing and parsing
│   ├── execute.c        # Process execution
│   ├── builtins.c       # Built-in commands
│   ├── redirect.c       # I/O redirection
│   ├── pipeline.c       # Pipeline handling
│   └── signals.c        # Signal handling
├── include/
│   ├── shell.h          # Common definitions
│   ├── parser.h
│   ├── execute.h
│   ├── builtins.h
│   ├── redirect.h
│   ├── pipeline.h
│   └── signals.h
└── tests/
    └── ...
```

### Interface Design

**parser.h**:

```c
// Parse input string into command structure
CommandLine *parse_command(char *input);

// Free command structure
void free_command_line(CommandLine *cmdline);
```

**builtins.h**:

```c
// Check if command is a built-in
int is_builtin(const char *name);

// Execute built-in command
int execute_builtin(Command *cmd);
```

**execute.h**:

```c
// Execute a single command
int execute_command(Command *cmd);

// Execute a pipeline
int execute_pipeline(CommandLine *cmdline);
```

## Error Handling Strategy

### Categories of Errors

1. **Parse Errors**: Invalid syntax
   - Example: Unclosed quote, invalid redirection
   - Action: Print error, continue shell loop

2. **System Call Errors**: fork, exec, open, pipe failures
   - Example: Can't fork, file not found
   - Action: Print error with perror(), return to prompt

3. **Built-in Errors**: Invalid arguments to built-ins
   - Example: `cd /nonexistent`
   - Action: Print error, return to prompt

### Error Reporting

```c
// Use errno and perror for system calls
if (fork() == -1) {
    perror("fork failed");
    return -1;
}

// Custom messages for parse/builtin errors
fprintf(stderr, "shell: syntax error near '%s'\n", token);
```

### Exit Codes

Follow shell conventions:

- 0: Success
- 1-125: Command returned error
- 126: Command found but not executable
- 127: Command not found
- 128+N: Killed by signal N

## Design Exercises

Before implementing, work through these design exercises:

### Exercise 1: Parse Flow

Draw a flowchart for parsing this command:

```
echo "hello world" | grep hello > output.txt
```

Steps to identify:

1. Tokenization
2. Quote handling
3. Pipe detection
4. Redirection detection
5. Data structure population

### Exercise 2: Pipeline Execution

Write pseudocode for executing a 3-command pipeline:

```
cat file.txt | grep pattern | sort
```

Consider:

- How many pipes needed?
- Order of fork calls
- File descriptor management in each child
- Parent waiting strategy

### Exercise 3: Built-in vs External

For each command, decide if it should be built-in or external:

- `cd /home` - Built-in (must change shell's directory)
- `ls -la` - External (doesn't need shell state)
- `export PATH=/usr/bin` - Built-in (modifies shell's environment)
- `echo hello` - Can be either (typically external for consistency)
- `exit` - Built-in (must terminate shell process)
- `pwd` - Can be either (built-in is faster)

### Exercise 4: Error Scenarios

Plan how to handle:

1. User types: `ls /nonexistent`
2. User types: `cat < missing.txt`
3. fork() fails (system out of resources)
4. Pipeline: `ls | /nonexistent | wc`
5. User presses Ctrl+C during `sleep 100`

## Implementation Roadmap

### Phase 1: Basic Shell (Week 1, Part 1)

- Main loop with prompt
- Read input with fgets()
- Simple parsing (no quotes, pipes, or redirection)
- Execute single commands with fork/exec
- Implement `exit` built-in

**Milestone**: Run simple commands like `ls`, `date`, `echo hello`

### Phase 2: Built-ins and Arguments (Week 1, Part 2)

- Parse command arguments correctly
- Implement `cd`, `export`, `unset`
- Handle empty input and comments
- Improve error messages

**Milestone**: Use `cd` to navigate, set environment variables

### Phase 3: I/O Redirection (Week 2, Part 1)

- Parse `<`, `>`, `>>`
- Implement file redirection using dup2()
- Handle redirection errors gracefully

**Milestone**: Run `ls > output.txt`, `cat < input.txt`

### Phase 4: Pipelines (Week 2, Part 2)

- Parse `|` operator
- Create pipes between commands
- Manage multiple children
- Wait for all processes

**Milestone**: Run `ls | grep test`, `cat file | sort | uniq`

### Phase 5: Polish (Week 3)

- Signal handling (Ctrl+C)
- Background processes with `&`
- Quote and escape handling
- Comprehensive testing
- Documentation

**Milestone**: Feature-complete, robust shell

## Testing Strategy

### Unit Tests

Test each component in isolation:

- Parser: Test with various inputs
- Built-ins: Test each built-in with edge cases
- Redirection: Test file operations
- Pipeline: Test pipe creation and management

### Integration Tests

Test complete commands:

```bash
# Create test script
./myshell < test_commands.txt

# Test commands file:
ls -la
cd /tmp
pwd
echo "hello" > test.txt
cat test.txt
rm test.txt
exit
```

### Edge Cases

- Empty input
- Very long commands
- Many arguments
- Multiple redirections
- Long pipelines
- Nonexistent commands
- Permission errors

## Tips for Success

1. **Start Simple**: Get basic command execution working before adding features

2. **Test Incrementally**: Test after each feature addition

3. **Use Man Pages**: `man 2 fork`, `man 2 pipe`, `man 2 dup2` are your friends

4. **Study Existing Shells**: Try commands in bash and observe behavior

5. **Draw Diagrams**: Visualize process trees and pipe connections

6. **Handle Errors**: Check every system call return value

7. **Avoid Memory Leaks**: Free all allocated memory, close all file descriptors

8. **Use Debugger**: gdb is essential for debugging fork/exec issues

## Next Step

Once you've designed your architecture and understand the components, proceed to the Shell Implementation step where you'll bring this design to life!
