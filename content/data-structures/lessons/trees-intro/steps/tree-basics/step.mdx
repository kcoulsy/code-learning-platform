---
id: tree-basics
title: Tree Basics
order: 1
---

# Tree Basics

A **tree** is a hierarchical data structure where each node can have multiple children. It's a fundamental structure for organizing hierarchical data.

## WHY Trees Exist

Trees solve problems where data has natural hierarchy:

**Real-world examples:**

- **File system**: Folders contain files and subfolders
- **Organization chart**: CEO → Managers → Employees
- **HTML DOM**: Elements nested within elements
- **Family tree**: Ancestors → Parents → Children

**Why not use arrays or linked lists?**

- Arrays: Hierarchical relationships don't map well
- Linked lists: Can only represent linear sequences

**Tree vs List:**

```
Array/Linked List:  A → B → C → D → E
                    Linear, one dimension

Tree:
        A
       / \
      B   C
     / \
    D   E
    Hierarchical, two dimensions
```

## HOW Trees Work

### Tree Terminology

```
                    A (Root)
                   / \
                  B   C (Siblings)
                 / \   \
                D   E   F
               (Leaves)

Relationships:
- A is parent of B and C
- B is child of A
- D, E, F are leaves (no children)
- B and C are siblings
- Path A→B→D has length 2
```

### Key Definitions

| Term       | Definition                                 |
| ---------- | ------------------------------------------ |
| **Root**   | Topmost node (no parent)                   |
| **Parent** | Node with children                         |
| **Child**  | Direct descendant of a parent              |
| **Leaf**   | Node with no children                      |
| **Edge**   | Connection between parent and child        |
| **Path**   | Sequence of edges from one node to another |
| **Depth**  | Number of edges from root to node          |
| **Height** | Number of edges from node to deepest leaf  |
| **Level**  | All nodes at same depth                    |

### Binary Tree Properties

For a binary tree with `n` nodes and height `h`:

| Property | Maximum             | Minimum             |
| -------- | ------------------- | ------------------- |
| Nodes    | 2^(h+1) - 1         | h + 1 (skewed tree) |
| Height   | O(log n) (balanced) | O(n) (skewed)       |
| Edges    | n - 1               | n - 1               |

**WHY minimum nodes = height + 1?**
A completely skewed tree has one node per level:

```
A        Level 0: 1 node
│
B        Level 1: 1 node
│
C        Level 2: 1 node
```

## Pseudo Code: Tree Operations

### Node Structure

```
DEFINE CLASS TreeNode:
    data: ANY
    left: POINTER TO TreeNode
    right: POINTER TO TreeNode

    CONSTRUCTOR(value):
        data = value
        left = NULL
        right = NULL
```

### Recursive Height Calculation

```
FUNCTION height(node):
    IF node == NULL:
        RETURN 0

    left_height = height(node.left)
    right_height = height(node.right)

    RETURN 1 + max(left_height, right_height)
```

**WHY this works:**

- Base case: Empty tree has height 0
- Recursive case: Height = 1 + max(left subtree height, right subtree height)
- Post-order traversal (children first, then parent)

### Node Count

```
FUNCTION count_nodes(node):
    IF node == NULL:
        RETURN 0

    left_count = count_nodes(node.left)
    right_count = count_nodes(node.right)

    RETURN 1 + left_count + right_count
```

### Check if Tree is Complete

```
FUNCTION is_complete(node, index, node_count):
    IF node == NULL:
        RETURN true

    IF index >= node_count:
        RETURN false

    left_complete = is_complete(node.left, 2*index + 1, node_count)
    right_complete = is_complete(node.right, 2*index + 2, node_count)

    RETURN left_complete AND right_complete
```

## Tree Traversal Methods

Trees have four main traversal orders:

### 1. Preorder (Root, Left, Right)

```
FUNCTION preorder(node):
    IF node == NULL:
        RETURN

    visit(node.data)           // Root first
    preorder(node.left)        // Then left subtree
    preorder(node.right)       // Then right subtree
```

**Output for sample tree: A, B, D, E, C, F**

**Use case:** Creating a copy of the tree (root processed first)

### 2. Inorder (Left, Root, Right)

```
FUNCTION inorder(node):
    IF node == NULL:
        RETURN

    inorder(node.left)         // Left subtree first
    visit(node.data)           // Then root
    inorder(node.right)        // Then right subtree
```

**Output for sample tree: D, B, E, A, C, F**

**Use case:** Binary search trees (gives sorted order)

### 3. Postorder (Left, Right, Root)

```
FUNCTION postorder(node):
    IF node == NULL:
        RETURN

    postorder(node.left)       // Left subtree first
    postorder(node.right)      // Then right subtree
    visit(node.data)           // Root last
```

**Output for sample tree: D, E, B, F, C, A**

**Use case:** Delete tree (children deleted before parent)

### 4. Level Order (Breadth-First)

```
FUNCTION level_order(root):
    IF root == NULL:
        RETURN

    queue = NEW Queue
    queue.enqueue(root)

    WHILE queue is not empty:
        node = queue.dequeue()
        visit(node.data)

        IF node.left != NULL:
            queue.enqueue(node.left)
        IF node.right != NULL:
            queue.enqueue(node.right)
```

**Output for sample tree: A, B, C, D, E, F**

**Use case:** Finding shortest path, level-by-level processing

## Pros and Cons

### Pros

| Advantage                     | Explanation                               |
| ----------------------------- | ----------------------------------------- |
| **Hierarchical Organization** | Natural fit for nested/recursive data     |
| **O(log n) Operations**       | In BSTs, search is logarithmic            |
| **Efficient Search**          | Binary search trees enable fast lookup    |
| **Ordered Data**              | Inorder traversal gives sorted sequence   |
| **Flexible Structure**        | Can model many real-world relationships   |
| **Natural Recursion**         | Tree algorithms often recursive (elegant) |

### Cons

| Disadvantage               | Explanation                           |
| -------------------------- | ------------------------------------- |
| **No Random Access**       | Must traverse from root               |
| **Overhead**               | Each node stores 2-3 pointers         |
| **Balancing Required**     | Unbalanced tree = O(n) operations     |
| **Complex Implementation** | Insert/delete require rebalancing     |
| **Memory Intensive**       | More memory than arrays for same data |

## When to Use Trees

### Use Trees When:

✓ Data has hierarchical structure  
✓ You need ordered/sorted data  
✓ You need fast search (with BST)  
✓ You need to represent expressions  
✓ You're doing compiler design (AST)  
✓ File system organization  
✓ DOM in web browsers

### Don't Use Trees When:

✗ Data is purely linear (use array/list)  
✗ You only need sequential access (use array)  
✗ Memory is extremely constrained  
✗ No ordering/search needed

## Tree Types

### By Structure

| Type              | Description                                                  |
| ----------------- | ------------------------------------------------------------ |
| **Binary Tree**   | Each node has at most 2 children                             |
| **N-ary Tree**    | Each node can have up to N children                          |
| **Full Tree**     | Every node has 0 or 2 children                               |
| **Complete Tree** | All levels filled except possibly last                       |
| **Perfect Tree**  | All internal nodes have 2 children, all leaves at same level |
| **Balanced Tree** | Height is O(log n) for n nodes                               |

### By Purpose

| Type                   | Use Case                          |
| ---------------------- | --------------------------------- |
| **Binary Search Tree** | Ordered storage, fast search      |
| **AVL Tree**           | Self-balancing BST                |
| **Red-Black Tree**     | Self-balancing, used in libraries |
| **B-Tree**             | Disk-based storage (databases)    |
| **Trie**               | String prefix searching           |
| **Heap**               | Priority queue, sorting           |
| **Segment Tree**       | Range queries                     |

## Key Takeaways

1. **Trees model hierarchy** - Perfect for nested structures
2. **Recursion is natural** - Tree algorithms are often recursive
3. **Four traversal orders** - Preorder, inorder, postorder, level-order
4. **Balancing is critical** - Unbalanced tree = degraded performance
5. **Different types for different needs** - BST, AVL, B-tree, etc.
6. **Height determines efficiency** - O(log n) operations need balanced tree
