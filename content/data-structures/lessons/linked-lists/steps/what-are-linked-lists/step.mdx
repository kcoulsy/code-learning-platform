---
id: what-are-linked-lists
title: What are Linked Lists?
order: 1
---

# What are Linked Lists?

A **linked list** is a collection of nodes where each node contains data and a **reference (pointer)** to the next node in the sequence.

## WHY Linked Lists Exist

Arrays have a critical limitation: **inserting or deleting in the middle requires shifting O(n) elements**. Linked lists solve this by storing each element as a separate node with a pointer to the next element.

**Problem with arrays when inserting in middle:**

```
Before: [10][20][30][40][50]
        Insert 25 at position 2

After:  [10][20][25][30][40][50]
        ^^^  ^^^  ^^^  ^^^
        Shifting 4 elements = O(n) operation
```

**Solution with linked list:**

```
Before: 10 -> 20 -> 30 -> 40 -> 50 -> NULL
         Insert 25 after 20

After:  10 -> 20 -> 25 -> 30 -> 40 -> 50 -> NULL
         Just change 2 pointers = O(1) operation
```

## HOW Linked Lists Work

### Memory Layout

Unlike arrays, linked list nodes can be scattered anywhere in memory:

```
Memory Address Map (nodes are NOT contiguous):
+------------------+     +------------------+     +------------------+
| 0x5000: data=10  |     | 0x3000: data=20  |     | 0x7000: data=30  |
| 0x5004: next=0x3000| -->| 0x3004: next=0x7000| -->| 0x7004: next=NULL|
+------------------+     +------------------+     +------------------+
      ^                        ^                        ^
      |                        |                        |
    Head                    Node 2                    Node 3
```

**WHY non-contiguous?** Each node is allocated separately with `malloc()`, so they end up wherever free memory exists.

### Node Structure

```
+------------------+
|     DATA (8B)    |  ← Can be any type (int, struct, etc.)
+------------------+
|   NEXT PTR (8B)  |  ← Address of next node (or NULL)
+------------------+
```

**Total node size = data_size + pointer_size**

For `int data`: 4 + 8 = 12 bytes (on 64-bit system)
For `struct` with 5 fields: 40 + 8 = 48 bytes

## Pseudo Code: Core Operations

### Node Structure (Language-Independent)

```
DEFINE CLASS Node:
    data: ANY
    next: POINTER TO Node

DEFINE CLASS LinkedList:
    head: POINTER TO Node
    tail: POINTER TO Node
    size: INTEGER
```

### Creating a Node

```
FUNCTION create_node(value):
    new_node = ALLOCATE(Node)
    new_node.data = value
    new_node.next = NULL
    RETURN new_node
```

### Insertion at Head (O(1))

```
FUNCTION insert_at_head(list, value):
    new_node = create_node(value)

    IF list.head == NULL:
        list.head = new_node
        list.tail = new_node
    ELSE:
        new_node.next = list.head
        list.head = new_node

    list.size = list.size + 1
    RETURN true
```

**WHY O(1)?** Only 3 pointer operations, no traversal needed.

### Insertion at Tail (O(1) with tail pointer)

```
FUNCTION insert_at_tail(list, value):
    new_node = create_node(value)

    IF list.head == NULL:
        list.head = new_node
        list.tail = new_node
    ELSE:
        list.tail.next = new_node
        list.tail = new_node

    list.size = list.size + 1
    RETURN true
```

**WHY O(1)?** Tail pointer gives direct access to end.

### Insertion at Position (O(n))

```
FUNCTION insert_at_position(list, value, position):
    IF position < 0 OR position > list.size:
        RETURN false

    IF position == 0:
        RETURN insert_at_head(list, value)

    IF position == list.size:
        RETURN insert_at_tail(list, value)

    // Find node before insertion point
    current = list.head
    FOR i FROM 1 TO position - 1:
        current = current.next

    // Insert new node
    new_node = create_node(value)
    new_node.next = current.next
    current.next = new_node

    list.size = list.size + 1
    RETURN true
```

**WHY O(n)?** Must traverse to find the position.

### Deletion (O(n) to find, O(1) to delete)

```
FUNCTION delete_by_value(list, value):
    IF list.head == NULL:
        RETURN false

    IF list.head.data == value:
        temp = list.head
        list.head = list.head.next
        IF list.head == NULL:
            list.tail = NULL
        FREE(temp)
        list.size = list.size - 1
        RETURN true

    current = list.head
    WHILE current.next != NULL:
        IF current.next.data == value:
            temp = current.next
            current.next = temp.next
            IF current.next == NULL:
                list.tail = current
            FREE(temp)
            list.size = list.size - 1
            RETURN true
        current = current.next

    RETURN false  // Value not found
```

### Search (O(n))

```
FUNCTION search(list, value):
    current = list.head
    index = 0
    WHILE current != NULL:
        IF current.data == value:
            RETURN index
        current = current.next
        index = index + 1
    RETURN -1  // Not found
```

**WHY O(n)?** Must follow pointers until found or end.

## Time Complexity Summary

| Operation         | Array  | Linked List | WHY Linked List                      |
| ----------------- | ------ | ----------- | ------------------------------------ |
| Access by index   | O(1)   | O(n)        | Must follow n pointers               |
| Search (by value) | O(n)   | O(n)        | Same (must examine each element)     |
| Insert at head    | O(n)   | O(1)        | Just update head pointer             |
| Insert at tail    | O(1)\* | O(1)\*\*    | \*\*With tail pointer                |
| Insert at middle  | O(n)   | O(n)        | Must find position first             |
| Delete at head    | O(n)   | O(1)        | Just update head pointer             |
| Delete at tail    | O(1)   | O(n)\*\*\*  | \*\*\*No back pointer in singly list |
| Delete at middle  | O(n)   | O(n)        | Must find position first             |

\*With reserved capacity  
**With tail pointer  
\***O(1) with doubly linked list

## Pros and Cons

### Pros

| Advantage                      | Explanation                                   |
| ------------------------------ | --------------------------------------------- |
| **O(1) Insert/Delete at Head** | No shifting needed, just update pointer       |
| **Dynamic Size**               | Grow/shrink without reallocation              |
| **No Memory Waste**            | Allocate exactly what you need                |
| **Insert in Middle (known)**   | O(1) if you already have the position pointer |
| **No Resizing Cost**           | Unlike arrays, no expensive realloc           |
| **Simple Recursion**           | Natural fit for recursive algorithms          |

### Cons

| Disadvantage               | Explanation                                    |
| -------------------------- | ---------------------------------------------- |
| **No Random Access**       | Must traverse from head, O(n) to access index  |
| **Memory Overhead**        | Each node stores a pointer (8 bytes on 64-bit) |
| **Poor Cache Performance** | Nodes scattered in memory                      |
| **More Complex Code**      | Pointer manipulation, memory management        |
| **No Binary Search**       | Cannot access middle directly                  |
| **Pointer Dereferencing**  | Slight CPU overhead per access                 |

## When to Use Linked Lists

### Use Linked Lists When:

✓ Frequent insertions/deletions at known positions  
✓ Size is unknown and changes frequently  
✓ You only access elements sequentially  
✓ Memory is abundant (overhead is acceptable)  
✓ You need a queue or stack implementation

### Don't Use Linked Lists When:

✗ You need random access by index  
✗ Cache performance is critical  
✗ Memory is constrained (overhead matters)  
✗ You need binary search

## Singly vs Doubly Linked Lists

### Singly Linked List

```
Head -> [data|next] -> [data|next] -> [data|next] -> NULL
```

**Characteristics:**

- Each node stores one pointer (next)
- Can only traverse forward
- Delete previous node is difficult (must find it)
- Less memory overhead

**Best for:** Stacks, simple queues

### Doubly Linked List

```
NULL <- [prev|data|next] <-> [prev|data|next] <-> [prev|data|next] -> NULL
```

**Characteristics:**

- Each node stores two pointers (prev, next)
- Can traverse forward and backward
- Can delete a node if you have it (no need to find previous)
- More memory overhead

**Best for:** Undo/redo functionality, browser history, LR caches

## Memory Allocation Strategy

### Node-by-Node Allocation

```
FOR i = 1 TO 1000:
    node = malloc(sizeof(Node))  // Each call finds free memory
    // Node goes wherever free memory exists
    // Memory becomes fragmented
```

**Problem:** Memory fragmentation over time.

### Pool Allocation (Optimization)

```c
#define POOL_SIZE 1000

typedef struct {
    Node nodes[POOL_SIZE];
    int used[POOL_SIZE];
    int next_free;
} NodePool;

Node *pool_alloc(NodePool *pool) {
    if (pool->next_free >= POOL_SIZE) {
        return NULL;  // Pool exhausted
    }
    int idx = pool->next_free++;
    pool->used[idx] = 1;
    return &pool->nodes[idx];
}

void pool_free(NodePool *pool, Node *node) {
    int idx = node - pool->nodes;
    pool->used[idx] = 0;
    // Can reuse this slot later
}
```

**Benefits:**

- Contiguous memory for all nodes
- Cache-friendly traversal
- No fragmentation
- Fast allocation (just increment index)

## Key Takeaways

1. **Linked lists solve the insertion/deletion problem** - No shifting, just pointer updates
2. **Trade access time for flexibility** - O(n) access for O(1) head insertion/deletion
3. **Memory overhead matters** - Each node needs a pointer (8 bytes on 64-bit)
4. **Cache performance suffers** - Nodes scattered in memory
5. **Use singly for stacks, doubly for complex operations**
6. **Consider pool allocation** for performance-critical applications
