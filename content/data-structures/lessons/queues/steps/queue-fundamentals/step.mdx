---
id: queue-fundamentals
title: Queue Fundamentals
order: 1
---

# Queue Fundamentals

A **queue** is a linear data structure that adds elements at the **rear** and removes from the **front**. This is FIFO (First In, First Out).

## WHY Queues Exist

Queues model real-world scenarios where order matters:

**Real-world analogies:**

- **Checkout line**: First person in line is first served
- **Print job queue**: First submitted job prints first
- **CPU task scheduling**: First arrived task gets processed first
- **Message queues**: First message sent is first received

**Why FIFO matters:**

```
Queue: [Customer1][Customer2][Customer3][Customer4]
        ^Front                           ^Rear

Dequeue: Customer1 gets served first
Enqueue: Customer5 joins at rear
```

## HOW Queues Work

### Visual Representation

```
Initial:     [ ][ ][ ][ ][ ]     front=0, rear=-1
Enqueue(1):  [1][ ][ ][ ][ ]     front=0, rear=0
Enqueue(2):  [1][2][ ][ ][ ]     front=0, rear=1
Enqueue(3):  [1][2][3][ ][ ]     front=0, rear=2
Dequeue():   [ ][2][3][ ][ ]     front=1, rear=2  (returns 1)
Dequeue():   [ ][ ][3][ ][ ]     front=2, rear=2  (returns 2)
Enqueue(4):  [ ][ ][3][4][ ]     front=2, rear=3
Enqueue(5):  [ ][ ][3][4][5]     front=2, rear=4
```

**Key insight:** Front and rear move in only one direction (forward). This is why "wasted space" accumulates at the front.

## Pseudo Code: Queue Operations

### Abstract Data Type

```
DEFINE CLASS Queue:
    items: LIST OF ELEMENT
    front: INTEGER
    rear: INTEGER
    size: INTEGER

    FUNCTION initialize():
        items = EMPTY_LIST
        front = 0
        rear = -1
        size = 0

    FUNCTION enqueue(value):
        rear = rear + 1
        items[rear] = value
        size = size + 1

    FUNCTION dequeue():
        IF is_empty():
            RETURN ERROR "Queue underflow"
        value = items[front]
        front = front + 1
        size = size - 1
        RETURN value

    FUNCTION peek():
        IF is_empty():
            RETURN ERROR "Queue empty"
        RETURN items[front]

    FUNCTION is_empty():
        RETURN size == 0
```

### Linear Queue Problems

```
PROBLEM: After many enqueue/dequeue operations

[ ][ ][3][4][5][6][7][8][9][10]
front=2                         rear=9

Space before front: 2 slots wasted!
Cannot add more even though only 8/10 used!
```

**This is why we need circular queues.**

### Circular Queue Logic

```
Key insight: Connect end back to beginning

ARRAY: [0][1][2][3][4][5]  (size 6)
               ^
         Modulo arithmetic

Enqueue when rear=5: rear = (5 + 1) % 6 = 0
                      Can reuse index 0!
```

```
FUNCTION enqueue_circular(queue, value):
    new_rear = (queue.rear + 1) % queue.capacity
    IF new_rear == queue.front:
        RETURN false  // Queue full
    queue.rear = new_rear
    queue.items[queue.rear] = value
    IF queue.front == -1:  // First element
        queue.front = 0
    RETURN true

FUNCTION dequeue_circular(queue):
    IF queue.front == -1:
        RETURN ERROR  // Queue empty
    value = queue.items[queue.front]
    IF queue.front == queue.rear:  // Last element
        queue.front = queue.rear = -1
    ELSE:
        queue.front = (queue.front + 1) % queue.capacity
    RETURN value
```

## Time Complexity Analysis

| Operation  | Linear Array | Circular Array | Linked List |
| ---------- | ------------ | -------------- | ----------- |
| Enqueue    | O(1)         | O(1)           | O(1)        |
| Dequeue    | O(1)         | O(1)           | O(1)        |
| Peek       | O(1)         | O(1)           | O(1)        |
| Space      | O(n)         | O(n)           | O(n)        |
| Full check | O(1)         | O(1)           | O(1)        |

## Pros and Cons

### Pros

| Advantage                    | Explanation                         |
| ---------------------------- | ----------------------------------- |
| **O(1) Enqueue and Dequeue** | Both ends accessible                |
| **FIFO Guarantee**           | First in, first out enforced        |
| **Simple Concept**           | Easy to understand and implement    |
| **Order Preserved**          | Elements processed in arrival order |
| **Essential for BFS**        | Breadth-first search requires queue |

### Cons

| Disadvantage           | Explanation                                |
| ---------------------- | ------------------------------------------ |
| **No Random Access**   | Cannot access middle elements              |
| **No Search by Value** | Must dequeue elements to find              |
| **Linear Queue Waste** | Wasted space at front (solved by circular) |
| **Fixed Size (array)** | Pre-allocation needed                      |

## When to Use Queues

### Use Queues When:

✓ You need FIFO processing  
✓ Task scheduling (first come, first served)  
✓ Breadth-first search (BFS)  
✓ Print job scheduling  
✓ Event handling  
✓ Message passing between threads  
✓ Buffering (stream processing)

### Don't Use Queues When:

✗ You need LIFO behavior (use stack instead)  
✗ You need random access  
✗ You need to access elements in middle

## Queue Types

### 1. Simple Queue (FIFO)

Basic queue as described above.

### 2. Circular Queue

Uses modulo arithmetic to reuse array space:

```
[5][6][7][8][9]  → After dequeue(5), dequeue(6)
   front=2        Enqueue(10): rear = (4 + 1) % 5 = 0

[10][6][7][8][9]  → 10 goes to position 0!
   front=2, rear=0
```

### 3. Priority Queue

Elements have priority; highest priority dequeued first:

```
Priority Queue: [(Priority, Value)]
[(3, "A"), (1, "B"), (2, "C")]

Dequeue: Returns "B" (priority 1 is highest)
         Queue becomes: [(3, "A"), (2, "C")]
```

**Implementation:** Usually with a heap (covered in Heaps lesson).

### 4. Double-Ended Queue (Deque)

Can add/remove from both ends:

```
[Front] ↔ [ ][ ][ ][ ][ ] ↔ [Rear]

Operations:
- Enqueue Front / Enqueue Rear
- Dequeue Front / Dequeue Rear
```

### 5. Blocking Queue

Used in concurrent programming:

```
- Enqueue blocks if queue is full
- Dequeue blocks if queue is empty
- Used for producer-consumer patterns
```

## BFS Algorithm (Why Queues Matter)

```
FUNCTION breadth_first_search(graph, start):
    visited = NEW Set
    queue = NEW Queue

    visited.add(start)
    queue.enqueue(start)

    WHILE queue is not empty:
        current = queue.dequeue()
        process(current)

        FOR each neighbor in graph[current]:
            IF neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
```

**WHY queue?** BFS visits all nodes at distance d before visiting distance d+1. Queue ensures we process nodes in the order they were discovered.

## Implementation Details

### Array-Based Queue (with circular buffer)

```c
#define CAPACITY 100

typedef struct {
    int items[CAPACITY];
    int front;
    int rear;
    int count;
} CircularQueue;

void init(CircularQueue *q) {
    q->front = -1;
    q->rear = -1;
    q->count = 0;
}

int isFull(CircularQueue *q) {
    return q->count == CAPACITY;
}

int isEmpty(CircularQueue *q) {
    return q->count == 0;
}

void enqueue(CircularQueue *q, int value) {
    if (isFull(q)) return;  // Overflow

    q->rear = (q->rear + 1) % CAPACITY;
    q->items[q->rear] = value;

    if (q->front == -1) {
        q->front = q->rear;  // First element
    }
    q->count++;
}

int dequeue(CircularQueue *q) {
    if (isEmpty(q)) return -1;  // Underflow

    int value = q->items[q->front];
    q->count--;

    if (q->front == q->rear) {
        q->front = q->rear = -1;  // Queue empty
    } else {
        q->front = (q->front + 1) % CAPACITY;
    }

    return value;
}
```

### Linked List Queue

```c
typedef struct QNode {
    int data;
    struct QNode *next;
} QNode;

typedef struct {
    QNode *front;
    QNode *rear;
    int size;
} LinkedQueue;

void enqueue(LinkedQueue *q, int value) {
    QNode *new = malloc(sizeof(QNode));
    new->data = value;
    new->next = NULL;

    if (q->rear == NULL) {
        q->front = q->rear = new;
    } else {
        q->rear->next = new;
        q->rear = new;
    }
    q->size++;
}

int dequeue(LinkedQueue *q) {
    if (q->front == NULL) return -1;

    QNode *temp = q->front;
    int value = temp->data;
    q->front = q->front->next;

    if (q->front == NULL) {
        q->rear = NULL;  // Queue empty
    }

    free(temp);
    q->size--;
    return value;
}
```

## Key Takeaways

1. **FIFO is the defining characteristic** - First in, first out
2. **Both enqueue and dequeue are O(1)** - Different ends, constant time
3. **Circular queues solve space waste** - Modulo arithmetic reuses array space
4. **Essential for BFS** - Level-order traversal needs FIFO
5. **Queues model real-world lines** - Fairness built into structure
6. **Priority queues are different** - Sorted by priority, not arrival time
