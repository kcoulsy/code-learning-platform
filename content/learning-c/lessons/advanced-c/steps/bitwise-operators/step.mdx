---
title: "Bitwise Operators"
description: "Master bitwise operations for efficient low-level programming, including AND, OR, XOR, NOT, and bit shifts."
order: 3
---

# Bitwise Operators

Bitwise operators work directly on the individual bits of integer values. While high-level programming often doesn't need bit manipulation, it's essential for systems programming, embedded development, networking, graphics, and performance-critical code.

Understanding bitwise operations gives you fine-grained control over data and enables techniques that are impossible with arithmetic operators alone. They're also much faster than arithmetic operations on most hardware.

## The Six Bitwise Operators

1. **AND (`&`)**: Bits are 1 only if both operands have 1
2. **OR (`|`)**: Bits are 1 if either operand has 1
3. **XOR (`^`)**: Bits are 1 if operands are different
4. **NOT (`~`)**: Flips all bits (0 becomes 1, 1 becomes 0)
5. **Left Shift (`<<`)**: Shifts bits left, filling with zeros
6. **Right Shift (`>>`)**: Shifts bits right

## Example 1: Basic Bitwise Operations

```c
#include <stdio.h>

// Helper function to print binary representation
void print_binary(unsigned int n, int bits) {
    for (int i = bits - 1; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i % 4 == 0 && i != 0) printf(" ");
    }
}

int main(void) {
    unsigned char a = 0b10110011;  // 179 in decimal
    unsigned char b = 0b11001010;  // 202 in decimal

    printf("a = ");
    print_binary(a, 8);
    printf(" (%d)\n", a);

    printf("b = ");
    print_binary(b, 8);
    printf(" (%d)\n\n", b);

    // AND: Both bits must be 1
    unsigned char and_result = a & b;
    printf("a & b  = ");
    print_binary(and_result, 8);
    printf(" (%d)\n", and_result);

    // OR: Either bit can be 1
    unsigned char or_result = a | b;
    printf("a | b  = ");
    print_binary(or_result, 8);
    printf(" (%d)\n", or_result);

    // XOR: Bits must be different
    unsigned char xor_result = a ^ b;
    printf("a ^ b  = ");
    print_binary(xor_result, 8);
    printf(" (%d)\n", xor_result);

    // NOT: Flip all bits (only showing 8 bits)
    unsigned char not_a = ~a;
    printf("~a     = ");
    print_binary(not_a, 8);
    printf(" (%d)\n\n", not_a);

    // Left shift: Multiply by 2^n
    unsigned char left = a << 2;
    printf("a << 2 = ");
    print_binary(left, 8);
    printf(" (%d) [multiply by 4]\n", left);

    // Right shift: Divide by 2^n
    unsigned char right = b >> 3;
    printf("b >> 3 = ");
    print_binary(right, 8);
    printf(" (%d) [divide by 8]\n", right);

    return 0;
}
```

**Output:**
```
a = 1011 0011 (179)
b = 1100 1010 (202)

a & b  = 1000 0010 (130)
a | b  = 1111 1011 (251)
a ^ b  = 0111 1001 (121)
~a     = 0100 1100 (76)

a << 2 = 1100 1100 (204) [multiply by 4]
b >> 3 = 0001 1001 (25) [divide by 8]
```

**Key Points:**
- `&` keeps only bits that are 1 in both operands
- `|` keeps bits that are 1 in either operand
- `^` keeps bits that are different between operands
- `~` flips all bits
- `<<` multiplies by powers of 2
- `>>` divides by powers of 2

## Example 2: Practical Bit Manipulation

```c
#include <stdio.h>

// Check if a specific bit is set
int is_bit_set(unsigned int value, int bit_position) {
    return (value >> bit_position) & 1;
}

// Set a specific bit to 1
unsigned int set_bit(unsigned int value, int bit_position) {
    return value | (1 << bit_position);
}

// Clear a specific bit (set to 0)
unsigned int clear_bit(unsigned int value, int bit_position) {
    return value & ~(1 << bit_position);
}

// Toggle a specific bit
unsigned int toggle_bit(unsigned int value, int bit_position) {
    return value ^ (1 << bit_position);
}

// Count the number of set bits (population count)
int count_set_bits(unsigned int value) {
    int count = 0;
    while (value) {
        count += value & 1;
        value >>= 1;
    }
    return count;
}

// Check if a number is a power of 2
int is_power_of_two(unsigned int value) {
    return value != 0 && (value & (value - 1)) == 0;
}

void print_binary(unsigned int n, int bits) {
    for (int i = bits - 1; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i % 4 == 0 && i != 0) printf(" ");
    }
}

int main(void) {
    unsigned char value = 0b10100100;  // 164

    printf("Original value: ");
    print_binary(value, 8);
    printf(" (%d)\n\n", value);

    // Check individual bits
    printf("Bit operations:\n");
    for (int i = 0; i < 8; i++) {
        printf("  Bit %d: %d\n", i, is_bit_set(value, i));
    }

    // Set bit 1
    unsigned char new_value = set_bit(value, 1);
    printf("\nAfter setting bit 1: ");
    print_binary(new_value, 8);
    printf(" (%d)\n", new_value);

    // Clear bit 5
    new_value = clear_bit(new_value, 5);
    printf("After clearing bit 5: ");
    print_binary(new_value, 8);
    printf(" (%d)\n", new_value);

    // Toggle bit 3
    new_value = toggle_bit(new_value, 3);
    printf("After toggling bit 3: ");
    print_binary(new_value, 8);
    printf(" (%d)\n", new_value);

    // Count set bits
    printf("\nNumber of set bits: %d\n", count_set_bits(value));

    // Test power of 2
    printf("\nPower of 2 tests:\n");
    unsigned int test_values[] = {1, 2, 3, 4, 7, 8, 16, 32, 33};
    for (size_t i = 0; i < sizeof(test_values) / sizeof(test_values[0]); i++) {
        printf("  %3d: %s\n", test_values[i],
               is_power_of_two(test_values[i]) ? "YES" : "NO");
    }

    return 0;
}
```

**Output:**
```
Original value: 1010 0100 (164)

Bit operations:
  Bit 0: 0
  Bit 1: 0
  Bit 2: 1
  Bit 3: 0
  Bit 4: 0
  Bit 5: 1
  Bit 6: 0
  Bit 7: 1

After setting bit 1: 1010 0110 (166)
After clearing bit 5: 1000 0110 (134)
After toggling bit 3: 1000 1110 (142)

Number of set bits: 3

Power of 2 tests:
    1: YES
    2: YES
    3: NO
    4: YES
    7: NO
    8: YES
   16: YES
   32: YES
   33: NO
```

**Key Points:**
- Use `1 << n` to create a mask with only bit n set
- AND with mask to check if bit is set
- OR with mask to set a bit
- AND with inverted mask to clear a bit
- XOR with mask to toggle a bit

## Example 3: Bit Manipulation Tricks

```c
#include <stdio.h>

// Swap two integers without a temporary variable
void swap(int *a, int *b) {
    if (a != b) {  // Only if they're different variables
        *a ^= *b;
        *b ^= *a;
        *a ^= *b;
    }
}

// Get the absolute value without branching
int abs_value(int x) {
    int mask = x >> 31;  // -1 if negative, 0 if positive
    return (x + mask) ^ mask;
}

// Find the minimum of two integers without branching
int min(int a, int b) {
    return b ^ ((a ^ b) & -(a < b));
}

// Find the maximum of two integers without branching
int max(int a, int b) {
    return a ^ ((a ^ b) & -(a < b));
}

// Check if two integers have opposite signs
int opposite_signs(int a, int b) {
    return (a ^ b) < 0;
}

// Round up to the next power of 2
unsigned int next_power_of_two(unsigned int x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
}

// Reverse bits in a byte
unsigned char reverse_bits(unsigned char b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

int main(void) {
    // Swap demonstration
    int x = 42, y = 17;
    printf("Before swap: x=%d, y=%d\n", x, y);
    swap(&x, &y);
    printf("After swap: x=%d, y=%d\n\n", x, y);

    // Absolute value
    printf("Absolute values:\n");
    printf("  abs(-15) = %d\n", abs_value(-15));
    printf("  abs(25) = %d\n\n", abs_value(25));

    // Min and max
    printf("Min and Max:\n");
    printf("  min(10, 20) = %d\n", min(10, 20));
    printf("  max(10, 20) = %d\n\n", max(10, 20));

    // Opposite signs
    printf("Opposite signs:\n");
    printf("  5 and -3: %s\n", opposite_signs(5, -3) ? "YES" : "NO");
    printf("  5 and 3: %s\n", opposite_signs(5, 3) ? "YES" : "NO");
    printf("  -5 and -3: %s\n\n", opposite_signs(-5, -3) ? "YES" : "NO");

    // Next power of 2
    printf("Next power of 2:\n");
    unsigned int values[] = {1, 5, 17, 33, 100};
    for (size_t i = 0; i < sizeof(values) / sizeof(values[0]); i++) {
        printf("  %d -> %d\n", values[i], next_power_of_two(values[i]));
    }
    printf("\n");

    // Reverse bits
    printf("Reverse bits:\n");
    unsigned char byte = 0b10110011;
    printf("  Original: 0x%02X (0b%08b)\n", byte,
           *(unsigned char*)&byte);
    byte = reverse_bits(byte);
    printf("  Reversed: 0x%02X (0b%08b)\n", byte,
           *(unsigned char*)&byte);

    return 0;
}
```

**Output:**
```
Before swap: x=42, y=17
After swap: x=17, y=42

Absolute values:
  abs(-15) = 15
  abs(25) = 25

Min and Max:
  min(10, 20) = 10
  max(10, 20) = 20

Opposite signs:
  5 and -3: YES
  5 and 3: NO
  -5 and -3: NO

Next power of 2:
  1 -> 1
  5 -> 8
  17 -> 32
  33 -> 64
  100 -> 128

Reverse bits:
  Original: 0xB3 (0b10110011)
  Reversed: 0xCD (0b11001101)
```

## Example 4: Real-World Applications

```c
#include <stdio.h>
#include <stdint.h>

// Extract RGB components from a 24-bit color
void extract_rgb(uint32_t color, uint8_t *r, uint8_t *g, uint8_t *b) {
    *r = (color >> 16) & 0xFF;
    *g = (color >> 8) & 0xFF;
    *b = color & 0xFF;
}

// Combine RGB components into a 24-bit color
uint32_t make_rgb(uint8_t r, uint8_t g, uint8_t b) {
    return (r << 16) | (g << 8) | b;
}

// Check if an IPv4 address is in a subnet
int is_in_subnet(uint32_t ip, uint32_t subnet, uint32_t mask) {
    return (ip & mask) == (subnet & mask);
}

// Fast multiplication by 10 using shifts and adds
int multiply_by_10(int x) {
    return (x << 3) + (x << 1);  // x*8 + x*2 = x*10
}

// Pack four bytes into a 32-bit integer
uint32_t pack_bytes(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3) {
    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3;
}

// Unpack 32-bit integer into four bytes
void unpack_bytes(uint32_t value, uint8_t *b0, uint8_t *b1,
                  uint8_t *b2, uint8_t *b3) {
    *b0 = (value >> 24) & 0xFF;
    *b1 = (value >> 16) & 0xFF;
    *b2 = (value >> 8) & 0xFF;
    *b3 = value & 0xFF;
}

int main(void) {
    // Color manipulation
    printf("Color manipulation:\n");
    uint32_t purple = make_rgb(128, 0, 128);
    printf("Purple color: 0x%06X\n", purple);

    uint8_t r, g, b;
    extract_rgb(purple, &r, &g, &b);
    printf("Components: R=%d, G=%d, B=%d\n\n", r, g, b);

    // IP address and subnet
    printf("IP subnet check:\n");
    uint32_t ip = (192 << 24) | (168 << 16) | (1 << 8) | 100;  // 192.168.1.100
    uint32_t subnet = (192 << 24) | (168 << 16) | (1 << 8) | 0;  // 192.168.1.0
    uint32_t mask = 0xFFFFFF00;  // 255.255.255.0

    printf("IP: 192.168.1.100\n");
    printf("Subnet: 192.168.1.0/24\n");
    printf("In subnet: %s\n\n", is_in_subnet(ip, subnet, mask) ? "YES" : "NO");

    // Fast multiplication
    printf("Fast multiplication:\n");
    printf("25 * 10 = %d\n\n", multiply_by_10(25));

    // Byte packing
    printf("Byte packing:\n");
    uint32_t packed = pack_bytes(0xDE, 0xAD, 0xBE, 0xEF);
    printf("Packed: 0x%08X\n", packed);

    uint8_t b0, b1, b2, b3;
    unpack_bytes(packed, &b0, &b1, &b2, &b3);
    printf("Unpacked: 0x%02X 0x%02X 0x%02X 0x%02X\n", b0, b1, b2, b3);

    return 0;
}
```

**Output:**
```
Color manipulation:
Purple color: 0x800080
Components: R=128, G=0, B=128

IP subnet check:
IP: 192.168.1.100
Subnet: 192.168.1.0/24
In subnet: YES

Fast multiplication:
25 * 10 = 250

Byte packing:
Packed: 0xDEADBEEF
Unpacked: 0xDE 0xAD 0xBE 0xEF
```

## Best Practices

1. **Use unsigned types**: Bitwise operations work best with unsigned integers
2. **Be clear with precedence**: Use parentheses to make operations explicit
3. **Comment bit operations**: They can be hard to understand at first glance
4. **Use named constants**: Define bit positions and masks with meaningful names
5. **Avoid signed right shift**: Behavior is implementation-defined for negative numbers
6. **Test thoroughly**: Bit operations are error-prone, especially with boundary conditions

## Common Use Cases

1. **Hardware control**: Setting and reading hardware registers
2. **Network protocols**: Parsing packet headers and flags
3. **Graphics**: Color manipulation and pixel operations
4. **Compression**: Efficient data storage and transmission
5. **Cryptography**: Bit-level transformations
6. **Optimization**: Fast arithmetic using shifts
7. **Sets**: Implementing sets using bit vectors

## Common Pitfalls

1. **Operator precedence**: `&` has lower precedence than `==`, use parentheses
2. **Signed vs unsigned**: Mixing signed and unsigned can cause issues
3. **Shift overflow**: Shifting by >= bit width is undefined behavior
4. **Endianness**: Byte order matters when working with multi-byte values
5. **Confusion with logical operators**: `&` vs `&&`, `|` vs `||`

## Exercises

1. **Bit Array**: Implement a bit array (bit vector) with functions to set, clear, and test bits. Store 1000 boolean values using only 125 bytes.

2. **Base Conversion**: Write functions to convert between binary, octal, decimal, and hexadecimal representations using bitwise operations.

3. **Parity Check**: Implement even and odd parity checkers. Add a parity bit to a byte and verify it.

4. **Bit Rotation**: Implement left and right bit rotation (circular shift) functions.

## Key Takeaways

- **Bitwise operators** work on individual bits: `&`, `|`, `^`, `~`, `<<`, `>>`
- **Use masks** to isolate, set, clear, or toggle specific bits
- **Shifts multiply/divide** by powers of 2 efficiently
- **XOR has special properties**: `x ^ x = 0`, `x ^ 0 = x`, useful for swapping
- **Power of 2 check**: `(x & (x-1)) == 0` for non-zero x
- **Fast operations**: Bit manipulation is faster than arithmetic for many tasks
- **Essential for systems programming**: Hardware, networking, embedded systems

In the next step, you'll learn how to use bit flags to efficiently manage multiple boolean states in a single variable.
